Python Linked List : Introduction | Built View Jobs Employers Join Log Jobs Companies Remote Articles Best Places Work items Data Science Expert Contributors Software Engineering Perspectives +1 Python Data Structures +3 Introduction Python Linked List Create Python linked list abstract data type presents linear collection data organized nodes link node . Build guide . Written Philip Wilkinson Published Sep. 30 , 2022 Image : Shutterstock / Built linked list abstract data type acts linear collection data elements organized collection nodes contains information node contains link node . main forms : singly linked list , direction links nodes , doubly - linked list , linked item list . benefit regular array list elements easily inserted removed changing index items . memory store linked list need reorganized data stored contiguously . , access items constant time ( O(1 ) ) like array looking item list linear time complexity ( O(n ) ) . Python Linked List ? Python linked list abstract data type Python allows users organize information nodes , link node list . makes easier insert remove information changing index items list . data structure useful : want insert items easily items . size total collection unknown . need random access searching items . concern memory usage storing data . Python Lists Built Experts Append Lists Python Create Linked List Python mind , begin think implement linked lists actual data structure Python . Key methods commonly associated include : insert ( ) : Add item linked list head list . find ( ) : Find item linked list . remove ( ) : Remove given item given value . is_empty ( ) : Returns linked list . get_count ( ) : Returns number items linked list . interesting natural data structure Python build construct linked list . queue stack , able utilize list data structure built Python . implement linked list , need construct node class . item linked list separate object contain information wants , identifying item linked list . attribute points , identifies , information contains , attribute points node linked list . , add behaviors allow extract data node contains node , ability set adjust attributes . , implemented : Class Node(object ): 

     def _ _ init__(self , val ): 
         self.val = val 
         self.next = 

     def get_data(self ): 
         return self.val 

     def set_data(self , val ): 
         self.val = val 
 
     def get_next(self ): 
         return self.next 
 
     def set_next(self , ): 
         self.next = val attributes correspond data node holds , pointing node linked list . fact originally set shows create beginning given node . add methods allow print current val node , ability change val set node . mind create linked list . focusing singly linked list means node link linked list , node implementation . Python Increase Readability Python Script 1 Simple Tool Build Singly Linked List Python step create constructor , called linked list created . instance , start attributes : Head : node linked list . Count : number nodes linked list . create head start linked list . means check head add item . add count attribute adding removing items , add minus . means want check items linked list , simply attribute loop entire list . creates tradeoff adding complexity adding removing functions , removing time complexity trying find length . implemented follows : Class LinkedList(object ): 

     def _ _ init__(self , head = ): 
         self.head = head 
         self.count = 0 Add Items Linked List Python linked list , important able add items , nodes , list . , focus adding items head linked list . , extended adding items list depending index item . way head simple makes good starting point . start instantiating new node , assigning data new node , setting new node current head list , setting head linked list new node . makes process nice easy low time complexity , compared thing standard list Python . implemented follows : def insert(self , data ): 
         " " " 
         Create new node Head Linked List 

         time complexity O(1 ) simply changing 
         current head Linked List indices   
         change 
         " " " 

         # create new node hold data 
         new_node = Node(data ) 
        
         # set new node current head 
         new_node.set_next(self.head ) 

         # set head Linked List new head 
         self.head = new_node 

         # add 1 count 
         self.count + = 1 add items linked list , thing want search linked list data linked list . multiple ways , including searching value index . focus searching value simplicity sake . ,    iterate linked list node data matches value searching . means worst - case scenario , iterate items linked list . , time complexity takes O(n ) . find item , return node . case value exist , return avoid errors thrown . def find(self , val ): 
         " " " 
         Search item Linked List data = val 
        
         Time complexity O(n ) worst case scenario 
         iterate Linked List 
         " " " 

         # start item Linked List 
         item = self.head 

         # iterate nodes 
         # item = end search 
         item ! = : 
           
            # data item matched val 
            # return item 
            item.get_data ( ) = = val : 
                return item 
           
            # item list 
            : 
                 item = item.get_next ( ) 

         # loop breaks found 
         # return 
         return Remove Items Python Linked List find items , deleting linked list ? want able add find items , want able remove items linked list . function constructed different ways , case , focus removing items certain value index . follows similar logic find function . main difference removing item linked list regular list linked list , node exist . change pointer previous node node node . makes removing items linked    list relatively easy compared regular list , items removed node index changed . connection nodes needs changed . implemented follows : def remove(self , item ): 
         " " " 
         Remove Node value equal item 

         Time complexity O(n ) worst case 
         iterate linked list 
         " " " 

         # set current node starting head 
         current = self.head 
         # create previous node hold 
         # node want remove 
         previous = 

         # current note search 
         current : 

             # current equals item break 
             current.data = = item : 
                 break 

             # set previous current 
             # current item list 
             previous = current 
             current = current.get_next ( ) 

         # current item , list 
         current : 
             raise ValueError(f"{item } list " ) 
         # previous item head 
         previous : 
             self.head = current.next 
             self.count -= 1 

         # remove node list 
         : 
              previous.set_next(current.get_next ( ) ) 
              self.count -= 1 Python Linked List Functions Know main functionality linked list created , start adding methods linked list simpler . supplementary methods add include getting length linked list seeing list . Python Write Nested List Comprehensions Python Finding Length Linked List method returning length linked relatively easy . way implemented constructor method , insert remove methods . , created count attribute , goes insert new nodes linked list goes away nodes remove method . , return value stored count attribute follows : def get_count(self ): 
         " " " 
         Return length Linked List 

         Time complexity O(1 ) returning single value 
         " " " 

         return self.count Determining Python Linked List seeing linked list ? similar way getting count attribute checking zero . simplicity sake , easily check linked list seeing head attribute . reason count attribute implemented properly , easily check head , indicate nodes . def is_empty(self ): 
         " " " 
         Returns Linked List 

         Time complexity O(1 ) returns True False 
         " " " 

         # check head 
         return self.head = = introduction Python linked lists . | Video : Brian Faure Putting Python Linked List , implemented main functionality singly linked list Python . remains , follows : Class Node(object ): 
  
     def _ _ init__(self , val ): 
         self.val = val 
         self.next = 
        
     def get_data(self ): 
         return self.val 
      
     def set_data(self , val ): 
         self.val = val 
 
     def get_next(self ): 
         return self.next 
 
     def set_next(self , ): 
         self.next = 
      
 
 Class LinkedList(object ): 
  
     def _ _ init__(self , head = ): 
         self.head = head 
         self.count = 0 
        
     def insert(self , data ): 
         " " " 
         Create new node Head Linked List 
         " " " 
         # create new node hold data 
         new_node = Node(data ) 
        
         # set new node current head 
         new_node.set_next(self.head ) 
        
         # set head Linked List new head 
         self.head = new_node 
        
         # add 1 count 
         self.count + = 1 
        
     def find(self , val ): 
         " " " 
         Search item Linked List data = val 
        
         Time complexity O(n ) worst case scenario 
         iterate Linked List 
         " " " 
         # start item Linked List 
         item = self.head 
         # iterate nodes 
         # item = end search 
         item ! = : 
           
            # data item matched val 
            # return item 
            item.get_data ( ) = = val : 
                return item 
           
            # item list 
            : 
                 item = item.get_next ( ) 
              
         # loop breaks found 
         # return 
         return 
  
     def remove(self , item ): 
         " " " 
         Remove Node value equal item 
         Time complexity O(n ) worst case 
         iterate linked list 
         " " " 
        
         # set current node starting head 
         current = self.head 
         # create previous node hold 
         # node want remove 
         previous = 
        
         # current note search 
         current : 
             # current equals item break 
             current.data = = item : 
                 break 
             # set previous current 
             # current item list 
             previous = current 
             current = current.get_next ( ) 
            
         # current item , list 
         current : 
             raise ValueError(f"{item } list " ) 
         # previous item head 
         previous : 
             self.head = current.next 
             self.count -= 1 
         # remove node list 
         : 
              previous.set_next(current.get_next ( ) ) 
              self.count -= 1 
              
     def get_count(self ): 
         " " " 
         Return length Linked List 
         Time complexity O(1 ) returning single value 
         " " " 
         return self.count 
      
     def is_empty(self ): 
         " " " 
         Returns Linked List 
         Time complexity O(1 ) returns True False 
         " " " 
         # check head 
         return self.head = = add functionality separately : deleteAt(index ) : Delete item given index findAt(index ) : Find item given index insertAt(index ) : Insert item given index extended doubly - linked list , node link previous node linked list . create linked list easier insert remove items . . course , aware drawbacks non - random access difficulty looking items , depend application linked list . Recent Data Science Articles Tableau ? 10 Python Image Manipulation Tools Try Today Python Databases 101 : Choose Database Library Explore Job Matches . Job Title Keyword Clear search Location Job Type Clear Apply Jobs Jobs Companies Articles Items Join Log Tech Jobs Companies Articles Remote Best Places Work Tech Hubs Post Job Built online community startups tech companies . Find 
             startup jobs , tech news events . Story Careers Staff Writers Content Descriptions Involved Recruit Built Expert Contributor Resources Customer Support Share Feedback Report Bug Browse Jobs Tech - Z Tech Hubs Sites Learning Lab User Agreement Accessibility Statement Copyright Policy Privacy Policy Terms Use Privacy Choices / Cookie Settings Notice Collection © Built 2025