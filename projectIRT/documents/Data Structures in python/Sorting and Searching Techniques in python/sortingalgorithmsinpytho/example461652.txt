Sorting Algorithms Python â€“ Real Python Start Â  Learn Python Python Tutorials Â  â†’ - depth articles video courses Learning Paths Â  â†’ Guided study plans accelerated learning Quizzes Â  â†’ Check learning progress Browse Topics Â  â†’ Focus specific area skill level Community Chat Â  â†’ Learn Pythonistas Office Hours Â  â†’ Live Q&A calls Python experts Podcast Â  â†’ Hear new world Python Books Â  â†’ Round knowledge learn offline Reference Â  â†’ Concise definitions common Python terms Code Mentor Â  â†’ Beta Personalized code assistance & learning tools Unlock Content Â  â†’ Learner Stories Python Newsletter Python Job Board Meet Team Tutorial Writer Video Instructor Search / Join Signâ€‘In â€” FREE Email Series â€” ðŸ Python Tricks ðŸ’Œ Python Tricks Â» ðŸ”’ spam . Unsubscribe time . Browse Topics Guided Learning Paths Basics Intermediate Advanced api best - practices career community databases data - science data - structures data - viz devops django docker editors flask - end gamedev gui machine - learning numpy projects python testing tools web - dev web - scraping Table Contents Importance Sorting Algorithms Python Python Built - Sorting Algorithm Significance Time Complexity Timing Code Measuring Efficiency Big O Notation Bubble Sort Algorithm Python Implementing Bubble Sort Python Measuring Bubble Sort Big O Runtime Complexity Timing Bubble Sort Implementation Analyzing Strengths Weaknesses Bubble Sort Insertion Sort Algorithm Python Implementing Insertion Sort Python Measuring Insertion Sort Big O Runtime Complexity Timing Insertion Sort Implementation Analyzing Strengths Weaknesses Insertion Sort Merge Sort Algorithm Python Implementing Merge Sort Python Measuring Merge Sort Big O Complexity Timing Merge Sort Implementation Analyzing Strengths Weaknesses Merge Sort Quicksort Algorithm Python Implementing Quicksort Python Selecting pivot Element Measuring Quicksort Big O Complexity Timing Quicksort Implementation Analyzing Strengths Weaknesses Quicksort Timsort Algorithm Python Implementing Timsort Python Measuring Timsort Big O Complexity Timing Timsort Implementation Analyzing Strengths Weaknesses Timsort Conclusion Mark Completed Share Recommended Video Course Introduction Sorting Algorithms Python Sorting Algorithms Python Santiago Valdarrama intermediate Mark Completed Share Table Contents Importance Sorting Algorithms Python Python Built - Sorting Algorithm Significance Time Complexity Timing Code Measuring Efficiency Big O Notation Bubble Sort Algorithm Python Implementing Bubble Sort Python Measuring Bubble Sort Big O Runtime Complexity Timing Bubble Sort Implementation Analyzing Strengths Weaknesses Bubble Sort Insertion Sort Algorithm Python Implementing Insertion Sort Python Measuring Insertion Sort Big O Runtime Complexity Timing Insertion Sort Implementation Analyzing Strengths Weaknesses Insertion Sort Merge Sort Algorithm Python Implementing Merge Sort Python Measuring Merge Sort Big O Complexity Timing Merge Sort Implementation Analyzing Strengths Weaknesses Merge Sort Quicksort Algorithm Python Implementing Quicksort Python Selecting pivot Element Measuring Quicksort Big O Complexity Timing Quicksort Implementation Analyzing Strengths Weaknesses Quicksort Timsort Algorithm Python Implementing Timsort Python Measuring Timsort Big O Complexity Timing Timsort Implementation Analyzing Strengths Weaknesses Timsort Conclusion Remove ads Watch tutorial related video course created Real Python team . Watch written tutorial deepen understanding : Introduction Sorting Algorithms Python Sorting basic building block algorithms built . related exciting ideas programming career . Understanding sorting algorithms Python work scenes fundamental step implementing correct efficient algorithms solve real - world problems . tutorial , learn : different sorting algorithms Python work compare different circumstances Python built - sort functionality works scenes different computer science concepts like recursion divide conquer apply sorting measure efficiency algorithm Big O notation Python timeit module end tutorial , understand sorting algorithms theoretical practical standpoint . importantly , deeper understanding different algorithm design techniques apply areas work . Let started ! Free Download : sample chapter Python Tricks : Book shows Python best practices simple examples apply instantly write beautiful + Pythonic code . Importance Sorting Algorithms Python Sorting thoroughly studied algorithms computer science . dozens different sorting implementations applications use code efficient effective . use sorting solve wide range problems : Searching : Searching item list works faster list sorted . Selection : Selecting items list based relationship rest items easier sorted data . example , finding k th -largest smallest value , finding median value list , easier values ascending descending order . Duplicates : Finding duplicate values list quickly list sorted . Distribution : Analyzing frequency distribution items list fast list sorted . example , finding element appears relatively straightforward sorted list . commercial applications academic research , countless ways use sorting save time effort . Remove ads Python Built - Sorting Algorithm Python language , like high - level programming languages , offers ability sort data box sorted ( ) . example sorting integer array : Python > > > array = [ 8 , 2 , 6 , 4 , 5 ] > > > sorted ( array ) [ 2 , 4 , 5 , 6 , 8 ] use sorted ( ) sort list long values inside comparable . Note : deeper dive Python built - sorting functionality works , check Use sorted ( ) .sort ( ) Python Sorting Data Python . Significance Time Complexity tutorial covers different ways measure runtime sorting algorithms : practical point view , measure runtime implementations timeit module . theoretical perspective , measure runtime complexity algorithms Big O notation . Timing Code comparing sorting algorithms Python , informative look long takes run . specific time algorithm takes partly determined hardware , use proportional time executions help decide implementation time efficient . section , focus practical way measure actual time takes run sorting algorithms timeit module . information different ways time execution code Python , check Python Timer Functions : Ways Monitor Code . function use time algorithms : Python 1 random import randint 2 timeit import repeat 3 4 def run_sorting_algorithm ( algorithm , array ): 5 # Set context prepare specified 6 # algorithm supplied array . import 7 # algorithm function built - ` sorted ( ) ` . 8 setup_code = f " _ _ main _ _ import { algorithm } " \ 9 algorithm ! = " sorted " " " 10 11 stmt = f " { algorithm } ( { array } ) " 12 13 # Execute code different times return time 14 # seconds execution took 15 times = repeat ( setup = setup_code , stmt = stmt , repeat = 3 , number = 10 ) 16 17 # Finally , display algorithm 18 # minimum time took run 19 print ( f " Algorithm : { algorithm } . Minimum execution time : { min ( times ) } " ) example , run_sorting_algorithm ( ) receives algorithm input array needs sorted . line - - line explanation works : Line 8 imports algorithm magic Python f - strings . timeit.repeat ( ) knows algorithm . Note necessary custom implementations tutorial . algorithm specified built - sorted ( ) , imported . Line 11 prepares algorithm supplied array . statement executed timed . Line 15 calls timeit.repeat ( ) setup code statement . specified sorting algorithm times , returning number seconds executions took . Line 19 identifies shortest time returned prints algorithm . Note : common misconception find average time run algorithm instead selecting single shortest time . Time measurements noisy system runs processes concurrently . shortest time noisy , making best representation algorithm true runtime . example use run_sorting_algorithm ( ) determine time takes sort array thousand integer values sorted ( ) : Python 21 ARRAY_LENGTH = 10000 22 23 _ _ _ _ = = " _ _ main _ _ " : 24 # Generate array ` ARRAY_LENGTH ` items consisting 25 # random integer values 0 999 26 array = [ randint ( 0 , 1000 ) range ( ARRAY_LENGTH ) ] 27 28 # function sorting algorithm 29 # array created 30 run_sorting_algorithm ( algorithm = " sorted " , array = array ) save code sorting.py file , run terminal output : Shell $ python sorting.py Algorithm : sorted . Minimum execution time : 0.010945824000000007 Remember time seconds experiment depends hardware use , likely slightly different results running code . Note : learn timeit module official Python documentation . Remove ads Measuring Efficiency Big O Notation specific time algorithm takes run information picture time complexity . solve problem , use Big O ( pronounced â€œ big oh â€ ) notation . Big O compare different implementations decide efficient , skipping unnecessary details focusing important runtime algorithm . time seconds required run different algorithms influenced unrelated factors , including processor speed available memory . Big O , hand , provides platform express runtime complexity hardware - agnostic terms . Big O , express complexity terms quickly algorithm runtime grows relative size input , especially input grows arbitrarily large . Assuming n size input algorithm , Big O notation represents relationship n number steps algorithm takes find solution . Big O uses capital letter â€œ O â€ followed relationship inside parentheses . example , O(n ) represents algorithms execute number steps proportional size input . tutorial going dive deep details Big O notation , examples runtime complexity different algorithms : Big O Complexity Description O(1 ) constant runtime constant regardless size input . Finding element hash table example operation performed constant time . O(n ) linear runtime grows linearly size input . function checks condition item list example O(n ) algorithm . O(n 2 ) quadratic runtime quadratic function size input . naive implementation finding duplicate values list , item checked twice , example quadratic algorithm . O(2 n ) exponential runtime grows exponentially size input . algorithms considered extremely inefficient . example exponential algorithm - coloring problem . O(log n ) logarithmic runtime grows linearly size input grows exponentially . example , takes second process thousand elements , seconds process thousand , seconds process thousand , . Binary search example logarithmic runtime algorithm . tutorial covers Big O runtime complexity sorting algorithms discussed . includes brief explanation determine runtime particular case . better understanding start Big O classify algorithms . Note : deeper understanding Big O , practical examples Python , check Big O Notation Algorithm Analysis Python Examples . Bubble Sort Algorithm Python Bubble Sort straightforward sorting algorithms . comes way algorithm works : new pass , largest element list â€œ bubbles â€ correct position . Bubble sort consists making multiple passes list , comparing elements , swapping adjacent items order . Implementing Bubble Sort Python implementation bubble sort algorithm Python : Python 1 def bubble_sort ( array ): 2 n = len ( array ) 3 4 range ( n ): 5 # Create flag allow function 6 # terminate early left sort 7 already_sorted = True 8 9 # Start looking item list , 10 # comparing adjacent value . 11 # iteration , portion array look 12 # shrinks remaining items 13 # sorted . 14 j range ( n - - 1 ): 15 array [ j ] > array [ j + 1 ] : 16 # item looking greater 17 # adjacent value , swap 18 array [ j ] , array [ j + 1 ] = array [ j + 1 ] , array [ j ] 19 20 # swap elements , 21 # set ` already_sorted ` flag ` False ` 22 # algorithm finish prematurely 23 already_sorted = False 24 25 # swaps iteration , 26 # array sorted , terminate 27 already_sorted : 28 break 29 30 return array implementation sorts array ascending order , step â€œ bubbles â€ largest element end array . means iteration takes fewer steps previous iteration continuously larger portion array sorted . loops lines 4 10 determine way algorithm runs list . Notice j initially goes element list element immediately . second iteration , j runs items , items , . end iteration , end portion list sorted . loops progress , line 15 compares element adjacent value , line 18 swaps incorrect order . ensures sorted list end function . Note : already_sorted flag lines 13 , 23 , 27 code optimization algorithm , required fully functional bubble sort implementation . , allows function skip unnecessary steps list ends wholly sorted loops finished . exercise , remove use flag compare runtimes implementations . properly analyze algorithm works , consider list values [ 8 , 2 , 6 , 4 , 5 ] . Assume bubble_sort ( ) . figure illustrating array looks like iteration algorithm : Bubble Sort Process step - - step look happening array algorithm progresses : code starts comparing element , 8 , adjacent element , 2 . 8 > 2 , values swapped , resulting following order : [ 2 , 8 , 6 , 4 , 5 ] . algorithm compares second element , 8 , adjacent element , 6 . 8 > 6 , values swapped , resulting following order : [ 2 , 6 , 8 , 4 , 5 ] . , algorithm compares element , 8 , adjacent element , 4 . 8 > 4 , swaps values , resulting following order : [ 2 , 6 , 4 , 8 , 5 ] . Finally , algorithm compares fourth element , 8 , adjacent element , 5 , swaps , resulting [ 2 , 6 , 4 , 5 , 8 ] . point , algorithm completed pass list ( = 0 ) . Notice value 8 bubbled initial location correct position end list . second pass ( = 1 ) takes account element list positioned focuses remaining elements , [ 2 , 6 , 4 , 5 ] . end pass , value 6 finds correct position . pass list positions value 5 , list sorted . Remove ads Measuring Bubble Sort Big O Runtime Complexity implementation bubble sort consists nested loops algorithm performs n - 1 comparisons , n - 2 comparisons , final comparison . comes total ( n - 1 ) + ( n - 2 ) + ( n - 3 ) + â€¦ + 2 + 1 = n(n-1)/2 comparisons , written Â½n 2 - Â½n . learned earlier Big O focuses runtime grows comparison size input . means , order turn equation Big O complexity algorithm , need remove constants change input size . simplifies notation n 2 - n . n 2 grows faster n , term dropped , leaving bubble sort average- worst - case complexity O(n 2 ) . cases algorithm receives array sorted â€” assuming implementation includes already_sorted flag optimization explained â€” runtime complexity come better O(n ) algorithm need visit element . O(n ) , , best - case runtime complexity bubble sort . mind best cases exception , focus average case comparing different algorithms . Timing Bubble Sort Implementation run_sorting_algorithm ( ) earlier tutorial , time takes bubble sort process array thousand items . Line 8 replaces algorithm stays : Python 1 _ _ _ _ = = " _ _ main _ _ " : 2 # Generate array ` ARRAY_LENGTH ` items consisting 3 # random integer values 0 999 4 array = [ randint ( 0 , 1000 ) range ( ARRAY_LENGTH ) ] 5 6 # function sorting algorithm 7 # array created 8 run_sorting_algorithm ( algorithm = " bubble_sort " , array = array ) run script execution time bubble_sort : Shell $ python sorting.py Algorithm : bubble_sort . Minimum execution time : 73.21720498399998 took 73 seconds sort array thousand elements . represents fastest execution repetitions run_sorting_algorithm ( ) runs . Executing script multiple times produce similar results . Note : single execution bubble sort took 73 seconds , algorithm ran times timeit.repeat ( ) . means expect code 73 * 10 = 730 seconds run , assuming similar hardware characteristics . Slower machines longer finish . Analyzing Strengths Weaknesses Bubble Sort main advantage bubble sort algorithm simplicity . straightforward implement understand . probably main reason computer science courses introduce topic sorting bubble sort . saw , disadvantage bubble sort slow , runtime complexity O(n 2 ) . Unfortunately , rules practical candidate sorting large arrays . Insertion Sort Algorithm Python Like bubble sort , insertion sort algorithm straightforward implement understand . unlike bubble sort , builds sorted list element time comparing item rest list inserting correct position . â€œ insertion â€ procedure gives algorithm . excellent analogy explain insertion sort way sort deck cards . Imagine holding group cards hands , want arrange order . start comparing single card step step rest cards find correct position . point , insert card correct location start new card , repeating cards hand sorted . Implementing Insertion Sort Python insertion sort algorithm works exactly like example deck cards . implementation Python : Python 1 def insertion_sort ( array ): 2 # Loop second element array 3 # element 4 range ( 1 , len ( array ) ): 5 # element want position 6 # correct place 7 key_item = array [ ] 8 9 # Initialize variable 10 # find correct position element referenced 11 # ` key_item ` 12 j = - 1 13 14 # Run list items ( left 15 # portion array ) find correct position 16 # element referenced ` key_item ` . 17 # ` key_item ` smaller adjacent values . 18 j > = 0 array [ j ] > key_item : 19 # Shift value position left 20 # reposition j point element 21 # ( right left ) 22 array [ j + 1 ] = array [ j ] 23 j -= 1 24 25 # finish shifting elements , position 26 # ` key_item ` correct location 27 array [ j + 1 ] = key_item 28 29 return array Unlike bubble sort , implementation insertion sort constructs sorted list pushing smaller items left . Let break insertion_sort ( ) line line : Line 4 sets loop determines key_item function position iteration . Notice loop starts second item list goes way item . Line 7 initializes key_item item function trying place . Line 12 initializes variable consecutively point element left key item . elements consecutively compared key_item . Line 18 compares key_item value left loop , shifting elements room place key_item . Line 27 positions key_item correct place algorithm shifts larger values right . figure illustrating different iterations algorithm sorting array [ 8 , 2 , 6 , 4 , 5 ] : Insertion Sort Process summary steps algorithm sorting array : algorithm starts key_item = 2 goes subarray left find correct position . case , subarray [ 8 ] . 2 < 8 , algorithm shifts element 8 position right . resultant array point [ 8 , 8 , 6 , 4 , 5 ] . elements subarray , key_item placed new position , final array [ 2 , 8 , 6 , 4 , 5 ] . second pass starts key_item = 6 goes subarray located left , case [ 2 , 8 ] . 6 < 8 , algorithm shifts 8 right . resultant array point [ 2 , 8 , 8 , 4 , 5 ] . 6 > 2 , algorithm need going subarray , positions key_item finishes second pass . time , resultant array [ 2 , 6 , 8 , 4 , 5 ] . pass list puts element 4 correct position , fourth pass places element 5 correct spot , leaving array sorted . Remove ads Measuring Insertion Sort Big O Runtime Complexity Similar bubble sort implementation , insertion sort algorithm couple nested loops list . inner loop pretty efficient goes list finds correct position element . said , algorithm O(n 2 ) runtime complexity average case . worst case happens supplied array sorted reverse order . case , inner loop execute comparison element correct position . gives O(n 2 ) runtime complexity . best case happens supplied array sorted . , inner loop executed , resulting O(n ) runtime complexity , like best case bubble sort . bubble sort insertion sort Big O runtime complexity , practice , insertion sort considerably efficient bubble sort . look implementation algorithms , insertion sort fewer comparisons sort list . Timing Insertion Sort Implementation prove assertion insertion sort efficient bubble sort , time insertion sort algorithm compare results bubble sort . , need replace run_sorting_algorithm ( ) insertion sort implementation : Python 1 _ _ _ _ = = " _ _ main _ _ " : 2 # Generate array ` ARRAY_LENGTH ` items consisting 3 # random integer values 0 999 4 array = [ randint ( 0 , 1000 ) range ( ARRAY_LENGTH ) ] 5 6 # function sorting algorithm 7 # array created 8 run_sorting_algorithm ( algorithm = " insertion_sort " , array = array ) execute script : Shell $ python sorting.py Algorithm : insertion_sort . Minimum execution time : 56.71029764299999 Notice insertion sort implementation took 17 fewer seconds bubble sort implementation sort array . O(n 2 ) algorithms , insertion sort efficient . Analyzing Strengths Weaknesses Insertion Sort like bubble sort , insertion sort algorithm uncomplicated implement . insertion sort O(n 2 ) algorithm , efficient practice quadratic implementations bubble sort . powerful algorithms , including merge sort Quicksort , implementations recursive usually fail beat insertion sort working small lists . Quicksort implementations use insertion sort internally list small provide faster overall implementation . Timsort uses insertion sort internally sort small portions input array . said , insertion sort practical large arrays , opening door algorithms scale efficient ways . Merge Sort Algorithm Python Merge sort efficient sorting algorithm . based divide - - conquer approach , powerful algorithmic technique solve complex problems . properly understand divide conquer , understand concept recursion . Recursion involves breaking problem smaller subproblems small manage . programming , recursion usually expressed function calling . Note : tutorial explore recursion depth . better understand recursion works action Python , check Thinking Recursively Python Recursion Python : Introduction . Divide - - conquer algorithms typically follow structure : original input broken parts , representing subproblem similar original simpler . subproblem solved recursively . solutions subproblems combined single overall solution . case merge sort , divide - - conquer approach divides set input values equal - sized parts , sorts half recursively , finally merges sorted parts single sorted list . Remove ads Implementing Merge Sort Python implementation merge sort algorithm needs different pieces : function recursively splits input half function merges halves , producing sorted array code merge different arrays : Python 1 def merge ( left , right ): 2 # array , needs 3 # merged , return second array result 4 len ( left ) = = 0 : 5 return right 6 7 # second array , needs 8 # merged , return array result 9 len ( right ) = = 0 : 10 return left 11 12 result = [ ] 13 index_left = index_right = 0 14 15 # arrays elements 16 # resultant array 17 len ( result ) < len ( left ) + len ( right ): 18 # elements need sorted add 19 # resultant array , need decide 20 # element second array 21 left [ index_left ] < = right [ index_right ] : 22 result . append ( left [ index_left ] ) 23 index_left + = 1 24 : 25 result . append ( right [ index_right ] ) 26 index_right + = 1 27 28 # reach end array , 29 # add remaining elements array 30 # result break loop 31 index_right = = len ( right ): 32 result + = left [ index_left :] 33 break 34 35 index_left = = len ( left ): 36 result + = right [ index_right :] 37 break 38 39 return result merge ( ) receives different sorted arrays need merged . process accomplish straightforward : Lines 4 9 check arrays . , merge , function returns array . Line 17 starts loop ends result contains elements supplied arrays . goal look arrays combine items produce sorted list . Line 21 compares elements head arrays , selects smaller value , appends end resultant array . Lines 31 35 append remaining items result elements arrays . function place , missing piece function recursively splits input array half uses merge ( ) produce final result : Python 41 def merge_sort ( array ): 42 # input array contains fewer elements , 43 # return result function 44 len ( array ) < 2 : 45 return array 46 47 midpoint = len ( array ) // 2 48 49 # Sort array recursively splitting input 50 # equal halves , sorting half merging 51 # final result 52 return merge ( 53 left = merge_sort ( array [: midpoint ] ) , 54 right = merge_sort ( array [ midpoint :] ) ) quick summary code : Line 44 acts stopping condition recursion . input array contains fewer elements , function returns array . Notice condition triggered receiving single item array . cases , left sort , function return . Line 47 computes middle point array . Line 52 calls merge ( ) , passing sorted halves arrays . Notice function calls recursively , halving array time . iteration deals - shrinking array fewer elements remain , meaning left sort . point , merge ( ) takes , merging halves producing sorted list . look representation steps merge sort sort array [ 8 , 2 , 6 , 4 , 5 ] : Merge Sort Process figure uses yellow arrows represent halving array recursion level . green arrows represent merging subarray . steps summarized follows : merge_sort ( ) [ 8 , 2 , 6 , 4 , 5 ] defines midpoint 2 . midpoint halve input array array[:2 ] array[2 :] , producing [ 8 , 2 ] [ 6 , 4 , 5 ] , respectively . merge_sort ( ) recursively called half sort separately . merge_sort ( ) [ 8 , 2 ] produces [ 8 ] [ 2 ] . process repeats halves . merge_sort ( ) [ 8 ] returns [ 8 ] element . happens merge_sort ( ) [ 2 ] . point , function starts merging subarrays merge ( ) , starting [ 8 ] [ 2 ] input arrays , producing [ 2 , 8 ] result . , [ 6 , 4 , 5 ] recursively broken merged procedure , producing [ 4 , 5 , 6 ] result . final step , [ 2 , 8 ] [ 4 , 5 , 6 ] merged merge ( ) , producing final result : [ 2 , 4 , 5 , 6 , 8 ] . Measuring Merge Sort Big O Complexity analyze complexity merge sort , look steps separately : merge ( ) linear runtime . receives arrays combined length n ( length original input array ) , combines arrays looking element . leads runtime complexity O(n ) . second step splits input array recursively calls merge ( ) half . array halved single element remains , total number halving operations performed function log 2 n . merge ( ) called half , total runtime O(n log 2 n ) . Interestingly , O(n log 2 n ) best possible worst - case runtime achieved sorting algorithm . Remove ads Timing Merge Sort Implementation compare speed merge sort previous implementations , use mechanism replace algorithm line 8 : Python 1 _ _ _ _ = = " _ _ main _ _ " : 2 # Generate array ` ARRAY_LENGTH ` items consisting 3 # random integer values 0 999 4 array = [ randint ( 0 , 1000 ) range ( ARRAY_LENGTH ) ] 5 6 # function sorting algorithm 7 # array created 8 run_sorting_algorithm ( algorithm = " merge_sort " , array = array ) execute script execution time merge_sort : Shell $ python sorting.py Algorithm : merge_sort . Minimum execution time : 0.6195857160000173 Compared bubble sort insertion sort , merge sort implementation extremely fast , sorting - thousand - element array second ! Analyzing Strengths Weaknesses Merge Sort Thanks runtime complexity O(n log 2 n ) , merge sort efficient algorithm scales size input array grows . straightforward parallelize breaks input array chunks distributed processed parallel necessary . said , small lists , time cost recursion allows algorithms bubble sort insertion sort faster . example , running experiment list elements results following times : Shell Algorithm : bubble_sort . Minimum execution time : 0.000018774999999998654 Algorithm : insertion_sort . Minimum execution time : 0.000029786000000000395 Algorithm : merge_sort . Minimum execution time : 0.00016983000000000276 bubble sort insertion sort beat merge sort sorting - element list . drawback merge sort creates copies array calling recursively . creates new list inside merge ( ) sort return input halves . makes merge sort use memory bubble sort insertion sort , able sort list place . limitation , want use merge sort sort large lists memory - constrained hardware . Quicksort Algorithm Python like merge sort , Quicksort algorithm applies divide - - conquer principle divide input array lists , small items second large items . algorithm sorts lists recursively resultant list completely sorted . Dividing input list referred partitioning list . Quicksort selects pivot element partitions list pivot , putting smaller element low array larger element high array . Putting element low list left pivot element high list right positions pivot precisely needs final sorted list . means function recursively apply procedure low high entire list sorted . Implementing Quicksort Python fairly compact implementation Quicksort : Python 1 random import randint 2 3 def quicksort ( array ): 4 # input array contains fewer elements , 5 # return result function 6 len ( array ) < 2 : 7 return array 8 9 low , , high = [ ] , [ ] , [ ] 10 11 # Select ` pivot ` element randomly 12 pivot = array [ randint ( 0 , len ( array ) - 1 ) ] 13 14 item array : 15 # Elements smaller ` pivot ` 16 # ` low ` list . Elements larger 17 # ` pivot ` ` high ` list . Elements 18 # equal ` pivot ` ` ` list . 19 item < pivot : 20 low . append ( item ) 21 elif item = = pivot : 22 . append ( item ) 23 elif item > pivot : 24 high . append ( item ) 25 26 # final result combines sorted ` low ` list 27 # ` ` list sorted ` high ` list 28 return quicksort ( low ) + + quicksort ( high ) summary code : Line 6 stops recursive function array contains fewer elements . Line 12 selects pivot element randomly list proceeds partition list . Lines 19 20 element smaller pivot list called low . Lines 21 22 element equal pivot list called . Lines 23 24 element larger pivot list called high . Line 28 recursively sorts low high lists combines contents list . illustration steps Quicksort takes sort array [ 8 , 2 , 6 , 4 , 5 ] : Quicksort Process yellow lines represent partitioning array lists : low , , high . green lines represent sorting putting lists . brief explanation steps : pivot element selected randomly . case , pivot 6 . pass partitions input array low contains [ 2 , 4 , 5 ] , contains [ 6 ] , high contains [ 8 ] . quicksort ( ) called recursively low input . selects random pivot breaks array [ 2 ] low , [ 4 ] , [ 5 ] high . process continues , point , low high fewer items . ends recursion , function puts array . Adding sorted low high list produces [ 2 , 4 , 5 ] . , high list containing [ 8 ] fewer elements , algorithm returns sorted low array , [ 2 , 4 , 5 ] . Merging ( [ 6 ] ) high ( [ 8 ] ) produces final sorted list . Remove ads Selecting pivot Element implementation select pivot element randomly ? consistently select element input list ? Quicksort algorithm works , number recursion levels depends pivot ends partition . best - case scenario , algorithm consistently picks median element pivot . generated subproblem exactly half size previous problem , leading log 2 n levels . hand , algorithm consistently picks smallest largest element array pivot , generated partitions unequal possible , leading n-1 recursion levels . worst - case scenario Quicksort . , Quicksort efficiency depends pivot selection . input array unsorted , element pivot work random element . input array sorted sorted , element pivot lead worst - case scenario . Selecting pivot random makes likely Quicksort select value closer median finish faster . option selecting pivot find median value array force algorithm use pivot . O(n ) time . process little bit involved , median value pivot Quicksort guarantees best - case Big O scenario . Measuring Quicksort Big O Complexity Quicksort , input list partitioned linear time , O(n ) , process repeats recursively average log 2 n times . leads final complexity O(n log 2 n ) . said , remember discussion selection pivot affects runtime algorithm . O(n ) best - case scenario happens selected pivot close median array , O(n 2 ) scenario happens pivot smallest largest value array . Theoretically , algorithm focuses finding median value uses pivot element , worst - case complexity come O(n log 2 n ) . median array found linear time , pivot guarantees Quicksort portion code perform O(n log 2 n ) . median value pivot , end final runtime O(n ) + O(n log 2 n ) . simplify O(n log 2 n ) logarithmic portion grows faster linear portion . Note : achieving O(n log 2 n ) possible Quicksort worst - case scenario , approach seldom practice . Lists large implementation faster simple randomized selection pivot . Randomly selecting pivot makes worst case unlikely . makes random pivot selection good implementations algorithm . Timing Quicksort Implementation , familiar process timing runtime algorithm . change algorithm line 8 : Python 1 _ _ _ _ = = " _ _ main _ _ " : 2 # Generate array ` ARRAY_LENGTH ` items consisting 3 # random integer values 0 999 4 array = [ randint ( 0 , 1000 ) range ( ARRAY_LENGTH ) ] 5 6 # function sorting algorithm 7 # array created 8 run_sorting_algorithm ( algorithm = " quicksort " , array = array ) execute script : Shell $ python sorting.py Algorithm : quicksort . Minimum execution time : 0.11675417600002902 Quicksort finish second , faster merge sort ( 0.11 seconds versus 0.61 seconds ) . Increasing number elements specified ARRAY_LENGTH 10,000 1,000,000 running script ends merge sort finishing 97 seconds , Quicksort sorts list mere 10 seconds . Analyzing Strengths Weaknesses Quicksort True , Quicksort fast . worst - case scenario theoretically O(n 2 ) , practice , good implementation Quicksort beats sorting implementations . , like merge sort , Quicksort straightforward parallelize . Quicksort main disadvantages lack guarantee achieve average runtime complexity . worst - case scenarios rare , certain applications afford risk poor performance , opt algorithms stay O(n log 2 n ) regardless input . like merge sort , Quicksort trades memory space speed . limitation sorting larger lists . quick experiment sorting list elements leads following results : Shell Algorithm : bubble_sort . Minimum execution time : 0.0000909000000000014 Algorithm : insertion_sort . Minimum execution time : 0.00006681900000000268 Algorithm : quicksort . Minimum execution time : 0.0001319930000000004 results Quicksort pays price recursion list sufficiently small , taking longer complete insertion sort bubble sort . Remove ads Timsort Algorithm Python Timsort algorithm considered hybrid sorting algorithm employs best - - - worlds combination insertion sort merge sort . Timsort near dear Python community created Tim Peters 2002 standard sorting algorithm Python language . main characteristic Timsort takes advantage - sorted elements exist real - world datasets . called natural runs . algorithm iterates list , collecting elements runs merging single sorted list . Implementing Timsort Python section , create barebones Python implementation illustrates pieces Timsort algorithm . interested , check original C implementation Timsort . step implementing Timsort modifying implementation insertion_sort ( ) : Python 1 def insertion_sort ( array , left = 0 , right = ): 2 right : 3 right = len ( array ) - 1 4 5 # Loop element indicated 6 # ` left ` element indicated ` right ` 7 range ( left + 1 , right + 1 ): 8 # element want position 9 # correct place 10 key_item = array [ ] 11 12 # Initialize variable 13 # find correct position element referenced 14 # ` key_item ` 15 j = - 1 16 17 # Run list items ( left 18 # portion array ) find correct position 19 # element referenced ` key_item ` . 20 # ` key_item ` smaller adjacent values . 21 j > = left array [ j ] > key_item : 22 # Shift value position left 23 # reposition ` j ` point element 24 # ( right left ) 25 array [ j + 1 ] = array [ j ] 26 j -= 1 27 28 # finish shifting elements , position 29 # ` key_item ` correct location 30 array [ j + 1 ] = key_item 31 32 return array modified implementation adds couple parameters , left right , indicate portion array sorted . allows Timsort algorithm sort portion array place . Modifying function instead creating new means reused insertion sort Timsort . look implementation Timsort : Python 1 def timsort ( array ): 2 min_run = 32 3 n = len ( array ) 4 5 # Start slicing sorting small portions 6 # input array . size slices defined 7 # ` min_run ` size . 8 range ( 0 , n , min_run ): 9 insertion_sort ( array , , min ( ( + min_run - 1 ) , n - 1 ) ) 10 11 # start merging sorted slices . 12 # Start ` min_run ` , doubling size 13 # iteration surpass length 14 # array . 15 size = min_run 16 size < n : 17 # Determine arrays 18 # merged 19 start range ( 0 , n , size * 2 ): 20 # Compute ` midpoint ` ( array ends 21 # second starts ) ` endpoint ` ( 22 # second array ends ) 23 midpoint = start + size - 1 24 end = min ( ( start + size * 2 - 1 ) , ( n - 1 ) ) 25 26 # Merge subarrays . 27 # ` left ` array ` start ` 28 # ` midpoint + 1 ` , ` right ` array 29 # ` midpoint + 1 ` ` end + 1 ` . 30 merged_array = merge ( 31 left = array [ start : midpoint + 1 ] , 32 right = array [ midpoint + 1 : end + 1 ] ) 33 34 # Finally , merged array 35 # array 36 array [ start : start + len ( merged_array ) ] = merged_array 37 38 # iteration double size arrays 39 size * = 2 40 41 return array implementation bit complex previous algorithms , summarize quickly following way : Lines 8 9 create small slices , runs , array sort insertion sort . learned previously insertion sort speedy small lists , Timsort takes advantage . Timsort uses newly introduced left right parameters insertion_sort ( ) sort list place having create new arrays like merge sort Quicksort . Line 16 merges smaller runs , run size 32 initially . iteration , size runs doubled , algorithm continues merging larger runs single sorted run remains . Notice , unlike merge sort , Timsort merges subarrays previously sorted . decreases total number comparisons required produce sorted list . advantage merge sort apparent running experiments different arrays . Finally , line 2 defines min_run = 32 . reasons 32 value : Sorting small arrays insertion sort fast , min_run small value advantage characteristic . Initializing min_run value large defeat purpose insertion sort algorithm slower . Merging balanced lists efficient merging lists disproportionate size . Picking min_run value power ensures better performance merging different runs algorithm creates . Combining conditions offers options min_run . implementation tutorial uses min_run = 32 possibilities . Note : practice , Timsort little complicated compute min_run . picks value 32 64 inclusive , length list divided min_run exactly power 2 . possible , chooses value close , strictly , power 2 . curious , read complete analysis pick min_run Computing minrun section . Measuring Timsort Big O Complexity average , complexity Timsort O(n log 2 n ) , like merge sort Quicksort . logarithmic comes doubling size run perform linear merge operation . , Timsort performs exceptionally - sorted close - - sorted lists , leading best - case scenario O(n ) . case , Timsort clearly beats merge sort matches best - case scenario Quicksort . worst case Timsort O(n log 2 n ) , surpasses Quicksort O(n 2 ) . Remove ads Timing Timsort Implementation use run_sorting_algorithm ( ) Timsort performs sorting - thousand - element array : Python 1 _ _ _ _ = = " _ _ main _ _ " : 2 # Generate array ` ARRAY_LENGTH ` items consisting 3 # random integer values 0 999 4 array = [ randint ( 0 , 1000 ) range ( ARRAY_LENGTH ) ] 5 6 # function sorting algorithm 7 # array created 8 run_sorting_algorithm ( algorithm = " timsort " , array = array ) execute script execution time timsort : Shell $ python sorting.py Algorithm : timsort . Minimum execution time : 0.5121690789999998 0.51 seconds , Timsort implementation 0.1 seconds , 17 percent , faster merge sort , match 0.11 Quicksort . ridiculous 11,000 percent faster insertion sort ! try sort - sorted list algorithms happens . modify _ _ main _ _ section follows : Python 1 _ _ _ _ = = " _ _ main _ _ " : 2 # Generate sorted array ARRAY_LENGTH items 3 array = [ range ( ARRAY_LENGTH ) ] 4 5 # functions 6 run_sorting_algorithm ( algorithm = " insertion_sort " , array = array ) 7 run_sorting_algorithm ( algorithm = " merge_sort " , array = array ) 8 run_sorting_algorithm ( algorithm = " quicksort " , array = array ) 9 run_sorting_algorithm ( algorithm = " timsort " , array = array ) execute script , algorithms run output corresponding execution time : Shell Algorithm : insertion_sort . Minimum execution time : 53.5485634999991 Algorithm : merge_sort . Minimum execution time : 0.372304601 Algorithm : quicksort . Minimum execution time : 0.24626494199999982 Algorithm : timsort . Minimum execution time : 0.23350277099999994 time , Timsort comes whopping thirty - seven percent faster merge sort percent faster Quicksort , flexing ability advantage - sorted runs . Notice Timsort benefits algorithms slower . genius Timsort combining algorithms playing strengths achieve impressive results . Analyzing Strengths Weaknesses Timsort main disadvantage Timsort complexity . Despite implementing simplified version original algorithm , requires code relies insertion_sort ( ) merge ( ) . Timsort advantages ability predictably perform O(n log 2 n ) regardless structure input array . Contrast Quicksort , degrade O(n 2 ) . Timsort fast small arrays algorithm turns single insertion sort . real - world usage , common sort arrays preexisting order , Timsort great option . adaptability makes excellent choice sorting arrays length . Conclusion Sorting essential tool Pythonista toolkit . knowledge different sorting algorithms Python maximize potential , ready implement faster , efficient apps programs ! tutorial , learned : Python built - sort ( ) works scenes Big O notation use compare efficiency different algorithms measure actual time spent running code implement different sorting algorithms Python pros cons different algorithms learned different techniques recursion , divide conquer , randomization . fundamental building blocks solving long list different algorithms , come researching . code presented tutorial , create new experiments , explore algorithms . Better , try implementing sorting algorithms Python . list vast , selection sort , heapsort , tree sort excellent options start . Mark Completed Share Watch tutorial related video course created Real Python team . Watch written tutorial deepen understanding : Introduction Sorting Algorithms Python ðŸ Python Tricks ðŸ’Œ short & sweet Python Trick delivered inbox couple days . spam . Unsubscribe time . Curated Real Python team . Send Python Tricks Â» Santiago Valdarrama Santiago software machine learning engineer specializes building enterprise software applications . Â» Santiago tutorial Real Python created team developers meets high quality standards . team members worked tutorial : Aldren Geir Arne Jon Joanna Jacob Master Real - World Python Skills Unlimited Access Real Â  Python Join access thousands tutorials , hands - video courses , community expert Â  Pythonistas : Level Python Skills Â» Master Real - World Python Skills Unlimited Access Real Â  Python Join access thousands tutorials , hands - video courses , community expert Pythonistas : Level Python Skills Â» Think ? Rate article : LinkedIn Twitter Bluesky Facebook Email # 1 takeaway favorite thing learned ? going newfound skills use ? Leave comment let know . Commenting Tips : useful comments written goal learning helping students . tips asking good questions answers common questions support portal . Looking real - time conversation ? Visit Real Python Community Chat join â€œ Office Â  Hours â€ Live Q&A Session . Happy Pythoning ! Learning Related Topics : intermediate Recommended Video Course : Introduction Sorting Algorithms Python Related Tutorials : Python Modules Packages â€“ Introduction Object - Oriented Programming ( OOP ) Python Recursion Python : Introduction Use Python Lambda Functions Build Hash Table Python TDD reading Real Â  Python creating free account signing Â  : Continue Â» account ? Sign - ! Complete form click button gain instant Â  access : Ã— " Python Tricks : Book " â€“ Free Sample Chapter ( PDF ) Send Sample Chapter Â» ðŸ”’ spam . privacy seriously . Remove ads Â© 2012â€“2025 Real Â  Python Â  â‹… Newsletter â‹… Podcast â‹… YouTube â‹… Twitter â‹… Facebook â‹… Instagram â‹… Python Â  Tutorials â‹… Search â‹… Privacy Policy â‹… Energy Policy â‹… Advertise â‹… Contact Happy Pythoning !