Sorting , searching algorithm analysis — Object - Oriented Programming Python 1 documentation Navigation index previous | Object - Oriented Programming Python 1 documentation » Sorting , searching algorithm analysis Sorting , searching algorithm analysis ¶ Introduction ¶ learned order write computer program 
 performs task construct suitable algorithm . , 
 algorithm construct unlikely unique – 
 likely possible algorithms perform task . 
 algorithms sense better ? 
 Algorithm analysis study question . chapter analyse algorithms ; 
 following common tasks : sorting : ordering list values searching : finding position value list Algorithm analysis begin clear statement task 
 performed . allows check algorithm 
 correct ensure algorithms comparing perform 
 task . ways algorithms compared , 
 focus primary importance data processing 
 algorithms : time complexity : number steps required depends 
 size input space complexity : extra memory storage 
 required depends size input Note Common sorting searching algorithms widely implemented 
 available programming languages . 
 seldom implement outside exercises 
 notes . important understand 
 basic algorithms , likely use 
 programs – space time complexity 
 affect algorithms . need select 
 specific sorting searching algorithm fit particular task , 
 require good understanding available options . Sorting algorithms ¶ sorting list values common computational task 
 studied extensively . classic description task 
 follows : Given list values function compares 
 values , order values list smallest largest . values integers , strings kinds 
 objects . examine algorithms : Selection sort , relies repeated selection 
 smallest item Merge sort , relies repeated merging sections 
 list sorted - known algorithms sorting lists insertion sort , bubble sort , heap sort , quicksort shell sort . algorithms perform sorting task 
 restricted kinds values , example : Counting sort , relies values belonging small set 
 items Bucket sort , relies ability map value 
 small set items Radix sort , relies values sequences digits restrict task , enlarge set algorithms 
 perform . new algorithms ones desirable 
 properties . example , Radix sort uses fewer steps generic 
 sorting algorithm . Selection sort ¶ order given list selection sort , repeatedly select 
 smallest remaining element end growing sorted 
 list . illustrate selection sort , let examine operates 
 small list elements : Initially entire list unsorted . use 
 list hold sorted items – avoid extra storage 
 space – start sorted list . find smallest element unsorted portion 
 list . element unsorted list candidate 
 compare following elements turn , replacing 
 candidate element found smaller . requires 3 
 comparisons find element 1.5 position 2 smallest . swap element unordered list 
 smallest element . start ordered list : repeat previous steps , determining 2.7 smallest 
 remaining element swapping 3.8 – element 
 current unordered section – : Finally , determine 3.8 smallest remaining 
 unordered elements swap 7.2 : table shows number operations type 
 sorting example list : Sorted List Length Comparisons Swaps Assign smallest candidate 0 - > 1 3 1 3 1 - > 2 2 1 2 2 - > 3 1 1 2 Total 6 3 7 Note number comparisons number swaps 
 independent contents list ( true selection 
 sort necessarily sorting algorithms ) 
 number times assign new value smallest 
 candidate depends contents list . generally , algorithm selection sort follows : Divide list sorted sorted portion 
 ( initially ) unsorted portion end ( initially 
 list ) . Find smallest element unsorted list : Select element unsorted list initial 
 candidate . Compare candidate element unsorted list 
 turn , replacing candidate current element 
 current element smaller . end unsorted list reached , candidate 
 smallest element . Swap smallest element found previous step 
 element unsorted list , extending sorted list 
 element . Repeat steps 2 3 element remains 
 unsorted list . Note Selection sort algorithm described properties 
 desirable sorting algorithms . algorithm - place . means 
 uses essentially extra storage required 
 input ( unsorted list case ) . little extra storage 
 ( example , temporary variable hold candidate 
 smallest element ) . important property extra 
 storage required increase size input 
 increases . second sorting algorithm stable . means 
 elements equal retain initial relative 
 ordering . important additional information 
 attached values sorted ( example , sorting 
 list people comparison function compares 
 dates birth ) . Stable sorting algorithms ensure sorting 
 sorted list leaves order list unchanged , 
 presence elements treated equal comparison . Exercise 1 ¶ Complete following code perform selection sort 
 Python . “ … ” denotes missing code filled : def selection_sort ( items ): " " " Sorts list items ascending order selection sort algorithm . " " " step range ( len ( items ) ): # Find location smallest element # items[step :] . location_of_smallest = step location range ( step , len ( items ) ): # TODO : determine location smallest ... # TODO : Exchange items[step ] items[location_of_smallest ] ... Exercise 2 ¶ Earlier section counted number comparisons , swaps assignments example . swaps performed apply selection sort list 
 N items ? comparisons performed apply selection sort 
 list N items ? comparisons performed find smallest 
 element unsorted portion list M items ? Sum values M encountered sorting list 
 length N find total number comparisons . number assignments ( candidate smallest number ) 
 performed search smallest element 
 number comparisons . Use find upper 
 limit total number assignments performed sorting 
 list length N. Use results previous question find upper bound 
 total number operations ( swaps , comparisons assignments ) 
 performed . term number operations dominate 
 large lists ? Merge sort ¶ use merge sort order list , repeatedly merge sorted 
 sub - sections list – starting sub - sections consisting 
 single item . shortly merge sort requires significantly fewer 
 operations selection sort . Let start small list elements : merge sections left temporary 
 storage . Imagine sections sorted piles cards – 
 merge piles repeatedly taking smaller 
 cards placing end merged list temporary 
 storage . piles , remaining items 
 pile placed end merged list : copy merged list temporary storage 
 portion list originally occupied merged subsections : repeat procedure merge second pair sorted sub - sections : Having reached end original list , return start 
 list begin merge sorted sub - sections . repeat 
 entire list single sorted sub - section . 
 example , requires merge : Notice size sorted sections list doubles 
 iteration merges . M steps size sorted 
 sections 2 M . 2 M greater N , 
 entire list sorted . , list size N , need M equals 
 log 2 N interations sort list . iteration merges requires complete pass list 
 element copied twice – temporary storage 
 original list . long items left 
 sub - sections pair , copy temporary list 
 requires comparison pick item copy . 
 lists runs , comparisons needed . pass requires 2N 
 copies roughly N comparisons ( certainly N ) . total number operations required merge sort algorithm 
 product number operations pass number 
 passes – i.e. 2Nlog 2 N copies roughly Nlog 2 N comparisons . algorithm merge sort written list steps : Create temporary storage list size list 
 sorted . Start treating element list sorted - element 
 sub - section original list . sorted sub - sections , merging adjacent pairs 
 follows : Use variables point indices smallest uncopied 
 items sorted sub - sections , variable 
 point index start temporary storage . Copy smaller indexed items indicated 
 position temporary storage . Increment index 
 sub - section item copied , index 
 temporary storage . items sub - section copied , copy 
 items remaining sub - section list 
 temporary storage . return step 3 ii . Copy sorted list temporary storage section 
 original list occupied sub - sections 
 merged . single sorted sub - section remains , entire list 
 sorted . return start step 3 . Exercise 3 ¶ Write Python function implements merge sort . help 
 write separate function performs merges 
 merge sort implementation . Python sorting algorithm ¶ Python default sorting algorithm , built - sorted function sort method list objects , 
 called Timsort .   algorithm developed Tim Peters 2002 
 use Python . Timsort modified version merge sort uses 
 insertion sort arrange list items conveniently mergeable 
 sections . Note Tim Peters credited author Zen Python – 
 attempt summarise early Python community ethos 
 short series koans . read typing import Python console . Searching algorithms ¶ Searching common - studied task . task 
 described formally follows : Given list values , function compares values desired value , find position desired value 
 list . look algorithms perform task : linear search , simply checks values sequence 
 desired value found binary search , requires sorted input list , checks 
 value middle list , repeatedly discarding half 
 list contains values definitely larger 
 smaller desired value numerous searching techniques . rely 
 construction complex data structures facilitate repeated 
 searching . Examples structures hash tables ( 
 Python dictionaries ) prefix trees . Inexact searches find 
 elements similar searched important 
 topic . Linear search ¶ Linear search basic kind search method . involves 
 checking element list turn , desired element 
 found . example , suppose want find number 3.8 
 following list : start element , perform comparison 
 value value want . case , 1.5 equal 
 3.8 , element : perform comparison , 2.7 equal 
 3.8 , element : perform comparison determine found 
 correct element . end search return position 
 element ( index 2 ) . use total 3 comparisons searching 
 list 4 elements . comparisons need perform depends 
 total length list , element 
 looking near beginning near end list . 
 worst - case scenario , element element list , 
 search entire list find . search list times , assuming elements 
 equally likely searched , average search 
 half list time .   cost ( comparisons ) 
 performing linear search scales linearly length 
 list . Exercise 4 ¶ Write function implements linear search . 
 list element parameter , return position 
 element list . element list , function 
 raise exception . element list multiple 
 times , function return position . Binary search ¶ Binary search efficient search algorithm relies 
 elements list sorted .   apply search process 
 progressively smaller sub - lists original list , starting 
 list approximately halving search area time . check middle element list . value want , stop . higher value want , repeat search 
 process portion list middle element . lower value want , repeat search 
 process portion list middle element . example , suppose want find value 3.8 
 following list 7 elements : compare element middle list 
 value . 7.2 bigger 3.8 , need check half 
 list . half list new list search .   compare 
 element middle list value .   2.7 smaller 3.8 , need search second half sublist . second half sub - list single element , 
 middle element .   compare element value , 
 element want . performed 3 comparisons total searching list 7 
 items .   number comparisons need perform scales 
 size list , slowly linear search – 
 searching list length N , maximum number comparisons 
 perform log 2 N. Exercise 5 ¶ Write function implements binary search . assume 
 input list sorted . Hint : function written 
 recursively . Algorithm complexity Big O notation ¶ commonly express cost algorithm function 
 number N elements algorithm acts .   function gives 
 estimate number operations perform order 
 use algorithm N elements – allows predict 
 number required operations increase N increases . use 
 function approximation exact function – 
 simplify possible , important 
 information preserved . example , know use linear search list N 
 elements , average search half list 
 find item – number operations 
 perform N/2 .   , important thing 
 algorithm scales linearly – N increases , cost 
 algorithm increases proportion N , N 2 N 3 .   constant factor 1/2 insignificant compared 
 large differences cost – example – N N 2 , leave describe cost 
 algorithm . write cost linear search algorithm O(N ) – 
 cost order N , order N .   
 notation big O notation , uses capital O symbol 
 ( order ) . dropped constant factor 1/2 . drop 
 lower - order terms expression multiple terms – 
 example , O(N 3 + N 2 ) simplified O(N 3 ) . example calculated average cost 
 algorithm , known expected cost , 
 useful calculate best case worst case costs .   
 best case , expected worst case costs sorting 
 searching algorithms discussed far : Algorithm Best case Expected Worst case Selection sort O(N 2 ) O(N 2 ) O(N 2 ) Merge sort O(N log N ) O(N log N ) O(N log N ) Linear search O(1 ) O(N ) O(N ) Binary search O(1 ) O(log N ) O(log N ) O(1 ) mean ? means cost algorithm constant , matter value N . search 
 algorithms , best case scenario happens element 
 tested correct element – perform 
 single operation find . previous table , big O notation describe time complexity algorithms .   describe 
 space complexity – case cost function represents 
 number units space required storage 
 required number operations .   space complexities 
 algorithms ( worst case , excluding space required 
 store input ): Algorithm Space complexity Selection sort O(1 ) Merge sort O(N ) Linear search O(1 ) Binary search O(1 ) algorithms require significant storage space 
 addition input list , merge sort 
 – , saw previous section , requires temporary storage 
 size input ( scales linearly 
 input size ) . Note Python wiki summary time 
 complexities common operations collections .   
 wish investigate collections module , provides 
 additional collection classes optimised particular 
 tasks . Note Computational complexity theory studies inherent complexity 
 tasks . possible prove algorithm perform given task require 
 minimum number steps extra storage .   example , 
 shown , given list arbitrary objects 
 comparison function compare , sorting 
 algorithm use fewer O(N log N ) comparisons . Exercise 6 ¶ comparison tables binary search 
 efficient linear search .   use linear 
 search ?   Hint : property list able 
 use binary search ? Suppose following functions shows average number 
 operations required perform algorithm list length 
 N. big O notation time complexity algorithm : 4N 2 + 2N + 2 N + log N N log N 3 Answers exercises ¶ Answer exercise 1 ¶ Completed selection sort implementation : def selection_sort ( items ): " " " Sorts list items ascending order selection sort algoright . " " " step range ( len ( items ) ): # Find location smallest element # items[step :] . location_of_smallest = step location range ( step , len ( items ) ): # determine location smallest items [ location ] < items [ location_of_smallest ] : location_of_smallest = location # Exchange items[step ] items[location_of_smallest ] temporary_item = items [ step ] items [ step ] = items [ location_of_smallest ] items [ location_of_smallest ] = temporary_item Answer exercise 2 ¶ N - 1 swaps performed . ( N - 1 ) * N / 2 comparisons performed . M - 1 comparisons performed finding smallest element . Summing M - 1 2 N gives : 1 + 2 + 3 + ... + ( N - 1 ) = ( N - 1 ) * N / 2 ( N - 1 ) * N / 2 + ( N - 1 ) assignements performed . N**2 + N - 2 operations performed . long lists 
 number operations grows N**2 . Answer exercise 3 ¶ example program : def merge ( items , sections , temporary_storage ): ( start_1 , end_1 ) , ( start_2 , end_2 ) = sections i_1 = start_1 i_2 = start_2 i_t = 0 i_1 < end_1 i_2 < end_2 : i_1 < end_1 i_2 < end_2 : items [ i_1 ] < items [ i_2 ] : temporary_storage [ i_t ] = items [ i_1 ] i_1 + = 1 : # the_list[i_2 ] > = items[i_1 ] temporary_storage [ i_t ] = items [ i_2 ] i_2 + = 1 i_t + = 1 elif i_1 < end_1 : range ( i_1 , end_1 ): temporary_storage [ i_t ] = items [ i_1 ] i_1 + = 1 i_t + = 1 : # i_2 < end_2 range ( i_2 , end_2 ): temporary_storage [ i_t ] = items [ i_2 ] i_2 + = 1 i_t + = 1 range ( i_t ): items [ start_1 + ] = temporary_storage [ ] def merge_sort ( items ): n = len ( items ) temporary_storage = [ ] * n size_of_subsections = 1 size_of_subsections < n : range ( 0 , n , size_of_subsections * 2 ): i1_start , i1_end = , min ( + size_of_subsections , n ) i2_start , i2_end = i1_end , min ( i1_end + size_of_subsections , n ) sections = ( i1_start , i1_end ) , ( i2_start , i2_end ) merge ( items , sections , temporary_storage ) size_of_subsections * = 2 return items Answer exercise 4 ¶ example program : def linear_search ( items , desired_item ): position , item enumerate ( items ): item = = desired_item : return position raise ValueError ( " % s found list . " % desired_item ) Answer exercise 5 ¶ example program : def binary_search ( items , desired_item , start = 0 , end = ): end = = : end = len ( items ) start = = end : raise ValueError ( " % s found list . " % desired_item ) pos = ( end - start ) // 2 + start desired_item = = items [ pos ] : return pos elif desired_item > items [ pos ] : return binary_search ( items , desired_item , start = ( pos + 1 ) , end = end ) : # desired_item < items[pos ] : return binary_search ( items , desired_item , start = start , end = pos ) Answer exercise 6 ¶ advantage linear search performed unsorted list – going examine values 
 turn , order matter . efficient 
 perform linear search binary search need find 
 value large unsorted list , sorting 
 list preparation performing binary search 
 expensive . , , need find values large 
 list multiple times , sorting list binary search 
 worthwhile . drop constant factors significant terms : O(N 2 ) O(N ) O(N log N ) O(1 ) Table Contents Sorting , searching algorithm analysis Introduction Sorting algorithms Selection sort Exercise 1 Exercise 2 Merge sort Exercise 3 Python sorting algorithm Searching algorithms Linear search Exercise 4 Binary search Exercise 5 Algorithm complexity Big O notation Exercise 6 Answers exercises Answer exercise 1 Answer exercise 2 Answer exercise 3 Answer exercise 4 Answer exercise 5 Answer exercise 6 Previous topic Introduction GUI programming tkinter Page Source Quick search Navigation index previous | Object - Oriented Programming Python 1 documentation » Sorting , searching algorithm analysis © Copyright 2013 , 2014 , University Cape Town individual contributors . work released CC - SA 4.0 licence . 
       Created Sphinx 7.2.6 .