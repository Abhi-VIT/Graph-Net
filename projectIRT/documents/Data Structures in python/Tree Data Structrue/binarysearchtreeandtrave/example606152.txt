Unlocking Secrets Binary Search Tree traversal Traversal : Preorder , Inorder , Postorder Explained | Medium Open app Sign Sign Write Sign Sign Binary Search Tree Traversal algorithms python Arjun Prakash Follow 9 min read · Nov 3 , 2023 -- Listen Share data structures ? Data structures ways methods store data computer , way data easily searched , sorted , inserted , modified deleted consuming lowest possible time space . numerous ways store data computer . store data form array ( continuous storing elements type ) , linked list ( multiple elements linked ) , HashMap , dictionary python ( key - > value store elements ) , binary tree ( discussed blog ) number ways . data structures situation , use different data structures combination algorithms optimally provide solution problem . , highest priority aspiring developers basics storing accessing data building complex software programs solve world problems . binary tree ? title blog , guessed predominantly talking binary tree blog . binary tree ? Binary means 2 tree software world means hierarchy . starts root , lot branches leaves(leaf ) branches , like tree . binary tree , single node 2 child nodes ( 2 maximum , minimum 0 ) . 2 nodes 4 nodes child ( 2 nodes * 2 nodes ) 4 nodes 8 nodes till 2^n nodes ( n depth tree ) . Terminologies binary tree Look image , green circle called node number stored value . node 1 called root node node . nodes 2 3 children node 1 parent node 4 , 5 , 5 7 . nodes children nodes called leaf nodes . Creating Binary Search Tree Python coding Binary Search Tree python right , hell Binary Search Tree ask ? Binary Search tree form binary tree , difference parent node child value greater right child value lesser left . root node value subsequent nodes added follow rule . Let example . suppose set number [ 3,4,7,2,6,8 ] Lets root node 4 , binary search tree look like particularly fast searching elements . average case time complexity particular data structure O(log n ) base 2 . code python ? 2 process step create class called Node define init method contain 3 values reference left node , reference right node data current node contains . 2 reference variables set value set given input . class Node : def _ _ init__(self , data ): self.left = self.right = self.data = data Secound step define method contains logic insert new elements binary search tree . basic logic smaller elements referenced left pointer node larger elements referenced right pointer node . class Node : def _ _ init__(self , data ): self.left = self.right = self.data = data def insert(self , data ): self.data : data < self.data : self.left : self.left = Node(data ) : self.left.insert(data ) elif data > self.data : self.right : self.right = Node(data ) : self.right.insert(data ) : self.data = data insert method class Node checks entered data null value ( possible compare null values right ? ) . condition check entered value lesser value current node . ilustrate example , lets [ 3,4,7,2,6,8 ] initialize root 4 . insert value 3 . 3 < 4 checks left node present . case present fore initilizes node like Node(3 ) inserts left Node(4 ) . value 7 . 7 > 4 fore right node checked , present Node(7 ) created inserted right . 2 entered . 2 < 4 , left node checked time , node present left branch Node(4 ) Node(3 ) . value 2 passed Node(3 ) step continued . 2 < 3 left Node(3 ) checked , node left branch Node(3 ) new node Node(2 ) created added left Node(3 ) . way values entered create tree Traversing binary tree Perfect ! learned store values binary tree , storing data gives purpose , accessed moments notice . binary tree normal sequential data structure , ways access elements bianry tree . Let discuss 3 ways access binary trees . Inorder Traversal method , left nodes accessed , center finally right . example , performing inorder traversal , result [ 2,3,4,6,7,8 ] def inorder(self , root ): res = [ ] root : res = self.inorder(root.left ) res.append(root.data ) res = res + self.inorder(root.right ) return res code perform inorder traversal . recursive code calls node values called , point value node returned . Let illustrate example . start algorithm , root node(4 ) , res node(4).left node(3 ) . algorithm implemented node(3 ) , s left node(2 ) . node 2 left fore value res . backtracking node(3 ) , res [ 2 ] 3 appended res . backtracking node(4 ) , res [ 2,3 ] , 4 appended node . second code , performs operation right tree node(4 ) . right node(4 ) node(7 ) , left node(6 ) . left right node(6 ) res [ 2,3,4,6 ] . backtracking , res [ 2,3,4,6,7 ] finally right node [ 2,3,4,6,7,8 ] algorithm stops roots traverse . Preorder traversal Preorder traversal method traversing binary tree , order nodes visited follows specific pattern : center node accessed , followed left nodes , right nodes . common way explore structure binary tree . def preorder(self , root ): res = [ ] root : res.append(root.data ) res = res + self.preorder(root.left ) res = res + self.preorder(root.right ) return res start algorithm , initializes list called res store nodes order visited . algorithm takes root tree input . begins visiting center node , root tree . value root node , denoted root.data , added res list . visiting center node , algorithm proceeds explore left subtree . calling recursively left child current node , root.left . continues traversal left branch tree . left subtree fully explored , algorithm backtracks parent node explores right subtree . accomplished calling recursively right child current node , root.right . recursion unwinds algorithm backtracks right subtree , results exploring left right subtrees concatenated value center node . creates final result current subtree . recursion proceeds , results subtrees , left right , appended res list , gradually building preorder traversal order entire tree . approach effectively visits center node , followed left right subtrees , resulting preorder traversal binary tree . let illustrate example Suppose binary tree root node 4 . Performing preorder traversal start visiting 4 , left subtree , visiting 3 2 order . , backtrack right subtree , visiting 7 , 6 , 8 . result preorder traversal [ 4 , 3 , 2 , 7 , 6 , 8 ] . Postorder Traversal Postorder traversal method traversing binary tree left subtree visited , followed right subtree , finally , center node processed . def postorder(self , root ): res = [ ] root : res = self.postorder(root.left ) res = res + self.postorder(root.right ) res.append(root.data ) return res algorithm commences visiting center node , root tree . value root node , represented root.data , immediately included res list . processing center node , algorithm shifts focus exploring left subtree . achieved calling recursively left child current node , accessed root.left . recursive propels traversal deeper left branch tree . left subtree thoroughly explored , algorithm initiates exploration right subtree . accomplished calling recursively right child current node , obtainable root.right . recursion unwinds , algorithm backtracks right subtree , ensures results obtained exploring left right subtrees amalgamated value center node . amalgamation forms final result current subtree . course recursion , results subtrees , encompassing left right , sequentially appended res list . gradual accumulation effectively constructs preorder traversal order entire binary tree . approach guarantees center node visited , followed exploration left right subtrees , resulting complete preorder traversal binary tree . illustration Final Code # Binary Search Tree class Node : def _ _ init__(self , data ): self.left = self.right = self.data = data def insert(self , data ): self.data : data < self.data : self.left : self.left = Node(data ) : self.left.insert(data ) elif data > self.data : self.right : self.right = Node(data ) : self.right.insert(data ) : self.data = data # traversal algorithms def inorder(self , root ): res = [ ] root : res = self.inorder(root.left ) res.append(root.data ) res = res + self.inorder(root.right ) return res def preorder(self , root ): res = [ ] root : res.append(root.data ) res = res + self.preorder(root.left ) res = res + self.preorder(root.right ) return res def postorder(self , root ): res = [ ] root : res = self.postorder(root.left ) res = res + self.postorder(root.right ) res.append(root.data ) return res Thank reading blog . value , consider giving follow connect LinkedIn ! Binary Search Tree Binary Tree Traversal Data Structures Algorithms Python Data Structures -- -- Follow Written Arjun Prakash 88 Followers · 75 Following tech enthusiast self - learning software engineer passionate web development , AI , ML , Data Science , things tech - related . Follow responses Help Status Careers Press Blog Privacy Rules Terms Text speech