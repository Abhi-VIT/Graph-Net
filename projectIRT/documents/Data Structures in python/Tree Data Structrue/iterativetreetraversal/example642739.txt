Iterative Tree Traversal | Python Plain English Open app Sign Sign Write Sign Sign Python Plain English · Follow publication New Python content day . Follow join 3.5M+ monthly readers . Follow publication Iterative Tree Traversal Ways visiting nodes Binary tree — Iteratively Amit Singh Rathore Follow 5 min read · 1 , 2022 -- Listen Share Photo Susan Q Yin Unsplash pretty straightforward write recursive code tree traversal . Stack internally recursion . blog , use stack queue implement tree traversals iteratively . Inorder Left Subtree→ Root→ Right Subtree Approach : Create stack push root node . declare variable track current node Run loop stack non - current node adding current node left stack . current node & stack pop element stack assign current node . process current node set current node current node right . def inorder_traversal(root ): res = [ ] root : return res stack = [ ] curr_node = root curr_node stack : curr_node : stack.append(curr_node ) curr_node = curr_node.left curr_node = stack.pop ( ) ; res.append(curr_node.val ) ; curr_node = curr_node.right ; return res Preorder Root → Left Subtree → Right Subtree Approach : Create stack push root node . declare variable track current node Run loop stack non - pop stack assign popped node current node process current node Push current node right left nodes def preorder_traversal(root ): res = [ ] root : return res stack = [ root ] stack : curr_node = stack.pop ( ) res.append(curr_node.val ) curr_node.right : stack.append(curr_node.right ) curr_node.left : stack.append(curr_node.left ) return res Postorder Left Subtree→ Right Subtree→ Root Approach : create stacks , track current node track right children . run loop till current node stack current node push current node right right child stack current node pushed stack current node set left child right child processed process current node right node processed process current node set current node . def postorder_traversal(root ): res = [ ] root : return res curr_node = root stack = [ ] right_stack = [ ] stack curr_node : curr_node : curr_node.right : right_stack.append(curr_node.right ) stack.append(curr_node ) curr_node = curr_node.left : curr_node = stack[-1 ] right_stack curr_node.right = = right_stack[-1 ] : curr_node = right_stack.pop ( ) : res.append(curr_node.val ) stack.pop ( ) curr_node = return res diagram summarizes array representation traversals . observations help regenerating Binary Tree given traversals . property build Tree given inorder postorder traversal . def buildTree(inorder , postorder ): in_order_idx , post_order_idx = len(inorder)-1 , len(postorder)-1 switch_side = False prev = root = TreeNode(postorder[post_order_idx ] ) stack = [ root ] post_order_idx -= 1 post_order_idx > = 0 : stack inorder[in_order_idx ] = = stack[-1].val : prev = stack.pop ( ) in_order_idx -= 1 switch_side = True : node = TreeNode(postorder[post_order_idx ] ) switch_side : prev.right = node prev = prev.right : prev.left = node prev = prev.left switch_side = False stack.append(node ) post_order_idx -= 1 return root Level order Root → Childrens →All children level Approach : use map data structure store nodes level . use queue process nodes . pop left queue process nodes add current node children end queue . , increment level node . def level_order(root ): root : return [ ] collections import deque q = deque([(root , 0 ) ] ) level_map = { } q : node , level = q.popleft ( ) level level_map : level_map[level ] = [ node.val ] : level_map[level].append(node.val ) node.left : q.append((node.left , level+1 ) ) node.right : q.append((node.right , level+1 ) ) n = max(level_map ) return [ level_map[level ] level range(n+1 ) ] Problems solved level order traversal : Left View Idea : index lists nodes level order traversal level . def right_view(root ): root : return [ ] level_map = { } collections import deque q = deque([(root , 0 ) ] ) q : node , level = q.popleft ( ) level level_map : level_map[level ] = node.val node.left : q.append((node.left , level+1 ) ) node.right : q.append((node.right , level+1 ) ) n = max(level_map ) return [ level_map[level ] level range(n+1 ) ] Right view Idea : index lists nodes level order traversal level . def right_view(root ): root : return [ ] level_map = { } collections import deque q = deque([(root , 0 ) ] ) q : node , level = q.popleft ( ) level_map[level ] = node.val node.left : q.append((node.left , level+1 ) ) node.right : q.append((node.right , level+1 ) ) n = max(level_map ) return [ level_map[level ] level range(n+1 ) ] Order traversal , maintain distance root ( left → -1 & right → +1 ) . store list nodes distance map object key distance . view Idea : element order traversal given distance visible . collections import deque def top_view(root ): root : return [ ] pos_map = { } q = deque([(root , 0 ) ] ) q : node , pos = q.popleft ( ) pos pos_map : pos_map[pos ] = node.val node.left : q.append((node.left , pos-1 ) ) node.right : q.append((node.right , pos+1 ) ) m , n = min(pos_map ) , max(pos_map ) return [ pos_map[pos ] pos range(m , n+1 ) ] View Idea : element order traversal given distance visible . collections import deque def top_view(root ): root : return [ ] pos_map = { } q = deque([(root , 0 ) ] ) q : node , pos = q.popleft ( ) pos_map[pos ] = node.val node.left : q.append((node.left , pos-1 ) ) node.right : q.append((node.right , pos+1 ) ) m , n = min(pos_map ) , max(pos_map ) return [ pos_map[pos ] pos range(m , n+1 ) ] Hope helps ! Happy coding ! content PlainEnglish.io . Sign free weekly newsletter . Follow Twitter LinkedIn . Join community Discord . Python Algorithms Data Structures Programming Trees -- -- Follow Published Python Plain English 47 K Followers · published New Python content day . Follow join 3.5M+ monthly readers . Follow Follow Written Amit Singh Rathore 4.6 K Followers · 101 Following Staff Data Engineer @ Visa — Writes Cloud | Big Data | ML Follow responses Help Status Careers Press Blog Privacy Rules Terms Text speech