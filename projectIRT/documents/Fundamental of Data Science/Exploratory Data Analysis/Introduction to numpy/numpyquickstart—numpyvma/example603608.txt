NumPy quickstart — NumPy v2.2 Manual Skip main content Ctrl + K User Guide API reference Building source Development Release notes Learn NEPs Choose version GitHub User Guide API reference Building source Development Release notes Learn NEPs Choose version GitHub Section Navigation Getting started NumPy ? Installation NumPy quickstart NumPy : absolute basics beginners Fundamentals usage NumPy fundamentals NumPy MATLAB users NumPy tutorials NumPy - tos Advanced usage interoperability NumPy C - API F2PY user guide reference manual - - hood documentation developers Interoperability NumPy Extras Glossary Release notes NumPy 2.0 migration guide NumPy license NumPy user guide NumPy quickstart NumPy quickstart # Prerequisites # need know bit Python . refresher , Python 
 tutorial . work examples , need matplotlib installed 
 addition NumPy . Learner profile quick overview arrays NumPy . demonstrates n - dimensional 
 ( \(n>=2\ ) ) arrays represented manipulated . particular , 
 know apply common functions n - dimensional arrays ( 
 - loops ) , want understand axis shape properties 
 n - dimensional arrays , article help . Learning Objectives reading , able : Understand difference one- , two- n - dimensional arrays 
 NumPy ; Understand apply linear algebra operations n - dimensional 
 arrays - loops ; Understand axis shape properties n - dimensional arrays . basics # NumPy main object homogeneous multidimensional array . 
 table elements ( usually numbers ) , type , indexed 
 tuple non - negative integers . NumPy dimensions called axes . example , array coordinates point 3D space , [ 1 , 2 , 1 ] , axis . axis 3 elements , 
 length 3 . example pictured , array 2 
 axes . axis length 2 , second axis length 
 3 . [ [ 1 . , 0 . , 0 . ] , [ 0 . , 1 . , 2 . ] ] NumPy array class called ndarray . known alias array . Note numpy.array Standard 
 Python Library class array.array , handles - dimensional 
 arrays offers functionality . important attributes 
 ndarray object : ndarray.ndim number axes ( dimensions ) array . ndarray.shape dimensions array . tuple integers indicating 
 size array dimension . matrix n rows 
 m columns , shape ( n , m ) . length shape tuple number axes , ndim . ndarray.size total number elements array . equal 
 product elements shape . ndarray.dtype object describing type elements array . 
 create specify dtype standard Python types . Additionally 
 NumPy provides types . numpy.int32 , numpy.int16 , 
 numpy.float64 examples . ndarray.itemsize size bytes element array . example , 
 array elements type float64 itemsize 8 (= 64/8 ) , 
 type complex32 itemsize 4 (= 32/8 ) . 
 equivalent ndarray.dtype.itemsize . ndarray.data buffer containing actual elements array . Normally , 
 wo need use attribute access elements 
 array indexing facilities . example # > > > import numpy np > > > = np . arange ( 15 ) . reshape ( 3 , 5 ) > > > array ( [ [ 0 ,   1 ,   2 ,   3 ,   4 ] , [ 5 ,   6 ,   7 ,   8 ,   9 ] , [ 10 , 11 , 12 , 13 , 14 ] ] ) > > > . shape ( 3 , 5 ) > > > . ndim 2 > > > . dtype . ' int64 ' > > > . itemsize 8 > > > . size 15 > > > type ( ) < class ' numpy.ndarray ' > > > > b = np . array ( [ 6 , 7 , 8 ] ) > > > b array([6 , 7 , 8 ] ) > > > type ( b ) < class ' numpy.ndarray ' > Array creation # ways create arrays . example , create array regular Python list tuple 
 array function . type resulting array deduced 
 type elements sequences . > > > import numpy np > > > = np . array ( [ 2 , 3 , 4 ] ) > > > array([2 , 3 , 4 ] ) > > > . dtype dtype('int64 ' ) > > > b = np . array ( [ 1.2 , 3.5 , 5.1 ] ) > > > b . dtype dtype('float64 ' ) frequent error consists calling array multiple arguments , 
 providing single sequence argument . > > > = np . array ( 1 , 2 , 3 , 4 ) # WRONG Traceback ( recent ): ... TypeError : array ( ) takes 1 2 positional arguments 4 given > > > = np . array ( [ 1 , 2 , 3 , 4 ] ) # RIGHT array transforms sequences sequences - dimensional arrays , 
 sequences sequences sequences - dimensional arrays , 
 . > > > b = np . array ( [ ( 1.5 , 2 , 3 ) , ( 4 , 5 , 6 ) ] ) > > > b array([[1.5 , 2 . , 3 . ] , [ 4 . , 5 . , 6 . ] ] ) type array explicitly specified creation time : > > > c = np . array ( [ [ 1 , 2 ] , [ 3 , 4 ] ] , dtype = complex ) > > > c array([[1.+0.j , 2.+0.j ] , [ 3.+0.j , 4.+0.j ] ] ) , elements array originally unknown , size 
 known . , NumPy offers functions create 
 arrays initial placeholder content . minimize necessity 
 growing arrays , expensive operation . function zeros creates array zeros , function ones creates array ones , function creates array initial content random depends 
 state memory . default , dtype created array float64 , specified key word argument dtype . > > > np . zeros ( ( 3 , 4 ) ) array([[0 . , 0 . , 0 . , 0 . ] , [ 0 . , 0 . , 0 . , 0 . ] , [ 0 . , 0 . , 0 . , 0 . ] ] ) > > > np . ones ( ( 2 , 3 , 4 ) , dtype = np . int16 ) array([[[1 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 ] ] , [ [ 1 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 ] ] ] , dtype = int16 ) > > > np . ( ( 2 , 3 ) ) array([[3.73603959e-262 , 6.02658058e-154 , 6.55490914e-260 ] ,   # vary [ 5.30498948e-313 , 3.14673309e-307 , 1.00000000e+000 ] ] ) create sequences numbers , NumPy provides arange function 
 analogous Python built - range , returns 
 array . > > > np . arange ( 10 , 30 , 5 ) array([10 , 15 , 20 , 25 ] ) > > > np . arange ( 0 , 2 , 0.3 ) # accepts float arguments array([0 . , 0.3 , 0.6 , 0.9 , 1.2 , 1.5 , 1.8 ] ) arange floating point arguments , generally 
 possible predict number elements obtained , 
 finite floating point precision . reason , usually better 
 use function linspace receives argument number 
 elements want , instead step : > > > numpy import pi > > > np . linspace ( 0 , 2 , 9 ) # 9 numbers 0 2 array([0 .   , 0.25 , 0.5 , 0.75 , 1 .   , 1.25 , 1.5 , 1.75 , 2 .   ] ) > > > x = np . linspace ( 0 , 2 * pi , 100 ) # useful evaluate function lots points > > > f = np . sin ( x ) array , zeros , zeros_like , ones , ones_like , , empty_like , arange , linspace , random.Generator.random , random.Generator.normal , fromfunction , fromfile Printing arrays # print array , NumPy displays similar way nested 
 lists , following layout : axis printed left right , second - - printed , rest printed , slice 
 separated line . - dimensional arrays printed rows , bidimensionals 
 matrices tridimensionals lists matrices . > > > = np . arange ( 6 ) # 1d array > > > print ( ) [ 0 1 2 3 4 5 ] > > > > > > b = np . arange ( 12 ) . reshape ( 4 , 3 ) # 2d array > > > print ( b ) [ [ 0   1   2 ] [ 3   4   5 ] [ 6   7   8 ] [ 9 10 11 ] ] > > > > > > c = np . arange ( 24 ) . reshape ( 2 , 3 , 4 ) # 3d array > > > print ( c ) [ [ [ 0   1   2   3 ] [ 4   5   6   7 ] [ 8   9 10 11 ] ] [ [ 12 13 14 15 ] [ 16 17 18 19 ] [ 20 21 22 23 ] ] ] 
 details reshape . array large printed , NumPy automatically skips 
 central array prints corners : > > > print ( np . arange ( 10000 ) ) [    0     1     2 ... 9997 9998 9999 ] > > > > > > print ( np . arange ( 10000 ) . reshape ( 100 , 100 ) ) [ [    0     1     2 ...    97    98    99 ] [ 100   101   102 ...   197   198   199 ] [ 200   201   202 ...   297   298   299 ] ... [ 9700 9701 9702 ... 9797 9798 9799 ] [ 9800 9801 9802 ... 9897 9898 9899 ] [ 9900 9901 9902 ... 9997 9998 9999 ] ] disable behaviour force NumPy print entire array , 
 change printing options set_printoptions . > > > np . set_printoptions ( threshold = sys . maxsize ) # sys module imported Basic operations # Arithmetic operators arrays apply elementwise . new array 
 created filled result . > > > = np . array ( [ 20 , 30 , 40 , 50 ] ) > > > b = np . arange ( 4 ) > > > b array([0 , 1 , 2 , 3 ] ) > > > c = - b > > > c array([20 , 29 , 38 , 47 ] ) > > > b * * 2 array([0 , 1 , 4 , 9 ] ) > > > 10 * np . sin ( ) array ( [ 9.12945251 , -9.88031624 ,   7.4511316 , -2.62374854 ] ) > > > < 35 array ( [ True ,   True , False , False ] ) Unlike matrix languages , product operator * operates 
 elementwise NumPy arrays . matrix product performed 
 @ operator ( python > = 3.5 ) dot function method : > > > = np . array ( [ [ 1 , 1 ] , ... [ 0 , 1 ] ] ) > > > B = np . array ( [ [ 2 , 0 ] , ... [ 3 , 4 ] ] ) > > > * B # elementwise product array([[2 , 0 ] , [ 0 , 4 ] ] ) > > > @ B # matrix product array([[5 , 4 ] , [ 3 , 4 ] ] ) > > > . dot ( B ) # matrix product array([[5 , 4 ] , [ 3 , 4 ] ] ) operations , + = * = , act place modify 
 existing array create new . > > > rg = np . random . default_rng ( 1 ) # create instance default random number generator > > > = np . ones ( ( 2 , 3 ) , dtype = int ) > > > b = rg . random ( ( 2 , 3 ) ) > > > * = 3 > > > array([[3 , 3 , 3 ] , [ 3 , 3 , 3 ] ] ) > > > b + = > > > b array([[3.51182162 , 3.9504637 , 3.14415961 ] , [ 3.94864945 , 3.31183145 , 3.42332645 ] ] ) > > > + = b # b automatically converted integer type Traceback ( recent ): ... numpy._core._exceptions._UFuncOutputCastingError : cast ufunc ' add ' output dtype('float64 ' ) dtype('int64 ' ) casting rule ' same_kind ' operating arrays different types , type resulting 
 array corresponds general precise ( behavior known 
 upcasting ) . > > > = np . ones ( 3 , dtype = np . int32 ) > > > b = np . linspace ( 0 , pi , 3 ) > > > b . dtype . ' float64 ' > > > c = + b > > > c array([1 .         , 2.57079633 , 4.14159265 ] ) > > > c . dtype . ' float64 ' > > > d = np . exp ( c * 1 j ) > > > d array ( [ 0.54030231 + 0.84147098j , -0.84147098 + 0.54030231j , -0.54030231 - 0.84147098j ] ) > > > d . dtype . ' complex128 ' unary operations , computing sum elements 
 array , implemented methods ndarray class . > > > = rg . random ( ( 2 , 3 ) ) > > > array([[0.82770259 , 0.40919914 , 0.54959369 ] , [ 0.02755911 , 0.75351311 , 0.53814331 ] ] ) > > > . sum ( ) 3.1057109529998157 > > > . min ( ) 0.027559113243068367 > > > . max ( ) 0.8277025938204418 default , operations apply array list 
 numbers , regardless shape . , specifying axis parameter apply operation specified axis 
 array : > > > b = np . arange ( 12 ) . reshape ( 3 , 4 ) > > > b array ( [ [ 0 ,   1 ,   2 ,   3 ] , [ 4 ,   5 ,   6 ,   7 ] , [ 8 ,   9 , 10 , 11 ] ] ) > > > > > > b . sum ( axis = 0 ) # sum column array([12 , 15 , 18 , 21 ] ) > > > > > > b . min ( axis = 1 ) # min row array([0 , 4 , 8 ] ) > > > > > > b . cumsum ( axis = 1 ) # cumulative sum row array ( [ [ 0 ,   1 ,   3 ,   6 ] , [ 4 ,   9 , 15 , 22 ] , [ 8 , 17 , 27 , 38 ] ] ) Universal functions # NumPy provides familiar mathematical functions sin , cos , 
 exp . NumPy , called “ universal 
 functions ” ( ufunc ) . NumPy , functions 
 operate elementwise array , producing array output . > > > B = np . arange ( 3 ) > > > B array([0 , 1 , 2 ] ) > > > np . exp ( B ) array([1 .         , 2.71828183 , 7.3890561 ] ) > > > np . sqrt ( B ) array([0 .         , 1 .         , 1.41421356 ] ) > > > C = np . array ( [ 2 . , - 1 . , 4 . ] ) > > > np . add ( B , C ) array([2 . , 0 . , 6 . ] ) , , apply_along_axis , argmax , argmin , argsort , average , bincount , ceil , clip , conj , corrcoef , cov , cross , cumprod , cumsum , diff , dot , floor , inner , invert , lexsort , max , maximum , mean , median , min , minimum , nonzero , outer , prod , , round , sort , std , sum , trace , transpose , var , vdot , vectorize , Indexing , slicing iterating # - dimensional arrays indexed , sliced iterated , 
 like lists Python sequences . > > > = np . arange ( 10 ) * * 3 > > > array ( [   0 ,    1 ,    8 ,   27 ,   64 , 125 , 216 , 343 , 512 , 729 ] ) > > > [ 2 ] 8 > > > [ 2 : 5 ] array ( [ 8 , 27 , 64 ] ) > > > # equivalent a[0:6:2 ] = 1000 ; > > > # start position 6 , exclusive , set 2nd element 1000 > > > [: 6 : 2 ] = 1000 > > > array([1000 ,     1 , 1000 ,    27 , 1000 ,   125 ,   216 ,   343 ,   512 ,   729 ] ) > > > [: : - 1 ] # reversed array ( [ 729 ,   512 ,   343 ,   216 ,   125 , 1000 ,    27 , 1000 ,     1 , 1000 ] ) > > > : ... print ( * * ( 1 / 3 . ) ) ... 9.999999999999998   # vary 1.0 9.999999999999998 3.0 9.999999999999998 4.999999999999999 5.999999999999999 6.999999999999999 7.999999999999999 8.999999999999998 Multidimensional arrays index axis . indices 
 given tuple separated commas : > > > def f ( x , y ): ... return 10 * x + y ... > > > b = np . fromfunction ( f , ( 5 , 4 ) , dtype = int ) > > > b array ( [ [ 0 ,   1 ,   2 ,   3 ] , [ 10 , 11 , 12 , 13 ] , [ 20 , 21 , 22 , 23 ] , [ 30 , 31 , 32 , 33 ] , [ 40 , 41 , 42 , 43 ] ] ) > > > b [ 2 , 3 ] 23 > > > b [ 0 : 5 , 1 ] # row second column b array ( [ 1 , 11 , 21 , 31 , 41 ] ) > > > b [: , 1 ] # equivalent previous example array ( [ 1 , 11 , 21 , 31 , 41 ] ) > > > b [ 1 : 3 , :] # column second row b array([[10 , 11 , 12 , 13 ] , [ 20 , 21 , 22 , 23 ] ] ) fewer indices provided number axes , missing 
 indices considered complete slices : > > > b [ - 1 ] # row . Equivalent b[-1 , :] array([40 , 41 , 42 , 43 ] ) expression brackets b[i ] treated followed instances : needed represent 
 remaining axes . NumPy allows write dots b[i , ... ] . dots ( ... ) represent colons needed produce 
 complete indexing tuple . example , x array 5 
 axes , x[1 , 2 , ... ] equivalent x[1 , 2 , : , : , :] , x [ ... , 3 ] x [: , : , : , : , 3 ] x[4 , ... , 5 , :] x[4 , : , : , 5 , :] . > > > c = np . array ( [ [ [ 0 , 1 , 2 ] , # 3D array ( stacked 2D arrays ) ... [ 10 , 12 , 13 ] ] , ... [ [ 100 , 101 , 102 ] , ... [ 110 , 112 , 113 ] ] ] ) > > > c . shape ( 2 , 2 , 3 ) > > > c [ 1 , ... ] # c[1 , : , :] c[1 ] array([[100 , 101 , 102 ] , [ 110 , 112 , 113 ] ] ) > > > c [ ... , 2 ] # c [: , : , 2 ] array ( [ [   2 ,   13 ] , [ 102 , 113 ] ] ) Iterating multidimensional arrays respect 
 axis : > > > row b : ... print ( row ) ... [ 0 1 2 3 ] [ 10 11 12 13 ] [ 20 21 22 23 ] [ 30 31 32 33 ] [ 40 41 42 43 ] , wants perform operation element 
 array , use flat attribute iterator elements array : > > > element b . flat : ... print ( element ) ... 0 1 2 3 10 11 12 13 20 21 22 23 30 31 32 33 40 41 42 43 Indexing ndarrays , Indexing routines ( reference ) , newaxis , ndenumerate , indices Shape manipulation # Changing shape array # array shape given number elements axis : > > > = np . floor ( 10 * rg . random ( ( 3 , 4 ) ) ) > > > array([[3 . , 7 . , 3 . , 4 . ] , [ 1 . , 4 . , 2 . , 2 . ] , [ 7 . , 2 . , 4 . , 9 . ] ] ) > > > . shape ( 3 , 4 ) shape array changed commands . Note 
 following commands return modified array , change 
 original array : > > > . ravel ( ) # returns array , flattened array([3 . , 7 . , 3 . , 4 . , 1 . , 4 . , 2 . , 2 . , 7 . , 2 . , 4 . , 9 . ] ) > > > . reshape ( 6 , 2 ) # returns array modified shape array([[3 . , 7 . ] , [ 3 . , 4 . ] , [ 1 . , 4 . ] , [ 2 . , 2 . ] , [ 7 . , 2 . ] , [ 4 . , 9 . ] ] ) > > > . T # returns array , transposed array([[3 . , 1 . , 7 . ] , [ 7 . , 4 . , 2 . ] , [ 3 . , 2 . , 4 . ] , [ 4 . , 2 . , 9 . ] ] ) > > > . T . shape ( 4 , 3 ) > > > . shape ( 3 , 4 ) order elements array resulting ravel 
 normally “ C - style ” , , rightmost index “ changes fastest ” , 
 element a[0 , 0 ] a[0 , 1 ] . array reshaped 
 shape , array treated “ C - style ” . NumPy normally 
 creates arrays stored order , ravel usually need 
 copy argument , array taking slices 
 array created unusual options , need copied . 
 functions ravel reshape instructed , 
 optional argument , use FORTRAN - style arrays , leftmost 
 index changes fastest . reshape function returns 
 argument modified shape , ndarray.resize method modifies array 
 : > > > array([[3 . , 7 . , 3 . , 4 . ] , [ 1 . , 4 . , 2 . , 2 . ] , [ 7 . , 2 . , 4 . , 9 . ] ] ) > > > . resize ( ( 2 , 6 ) ) > > > array([[3 . , 7 . , 3 . , 4 . , 1 . , 4 . ] , [ 2 . , 2 . , 7 . , 2 . , 4 . , 9 . ] ] ) dimension given -1 reshaping operation , 
 dimensions automatically calculated : > > > . reshape ( 3 , - 1 ) array([[3 . , 7 . , 3 . , 4 . ] , [ 1 . , 4 . , 2 . , 2 . ] , [ 7 . , 2 . , 4 . , 9 . ] ] ) ndarray.shape , reshape , resize , ravel Stacking different arrays # arrays stacked different axes : > > > = np . floor ( 10 * rg . random ( ( 2 , 2 ) ) ) > > > array([[9 . , 7 . ] , [ 5 . , 2 . ] ] ) > > > b = np . floor ( 10 * rg . random ( ( 2 , 2 ) ) ) > > > b array([[1 . , 9 . ] , [ 5 . , 1 . ] ] ) > > > np . vstack ( ( , b ) ) array([[9 . , 7 . ] , [ 5 . , 2 . ] , [ 1 . , 9 . ] , [ 5 . , 1 . ] ] ) > > > np . hstack ( ( , b ) ) array([[9 . , 7 . , 1 . , 9 . ] , [ 5 . , 2 . , 5 . , 1 . ] ] ) function column_stack stacks 1D arrays columns 2D array . 
 equivalent hstack 2D arrays : > > > numpy import newaxis > > > np . column_stack ( ( , b ) ) # 2D arrays array([[9 . , 7 . , 1 . , 9 . ] , [ 5 . , 2 . , 5 . , 1 . ] ] ) > > > = np . array ( [ 4 . , 2 . ] ) > > > b = np . array ( [ 3 . , 8 . ] ) > > > np . column_stack ( ( , b ) ) # returns 2D array array([[4 . , 3 . ] , [ 2 . , 8 . ] ] ) > > > np . hstack ( ( , b ) ) # result different array([4 . , 2 . , 3 . , 8 . ] ) > > > [: , newaxis ] # view ` ` 2D column vector array([[4 . ] , [ 2 . ] ] ) > > > np . column_stack ( ( [: , newaxis ] , b [: , newaxis ] ) ) array([[4 . , 3 . ] , [ 2 . , 8 . ] ] ) > > > np . hstack ( ( [: , newaxis ] , b [: , newaxis ] ) ) # result array([[4 . , 3 . ] , [ 2 . , 8 . ] ] ) general , arrays dimensions , hstack stacks second 
 axes , vstack stacks 
 axes , concatenate allows optional arguments giving number axis 
 concatenation happen . Note complex cases , r _ c _ useful creating arrays stacking 
 numbers axis . allow use range literals : . > > > np . r _ [ 1 : 4 , 0 , 4 ] array([1 , 2 , 3 , 0 , 4 ] ) arrays arguments , r _ c _ similar vstack hstack default behavior , 
 allow optional argument giving number axis 
 concatenate . hstack , vstack , column_stack , concatenate , c _ , r _ Splitting array smaller ones # hsplit , split 
 array horizontal axis , specifying number 
 equally shaped arrays return , specifying columns 
 division occur : > > > = np . floor ( 10 * rg . random ( ( 2 , 12 ) ) ) > > > array([[6 . , 7 . , 6 . , 9 . , 0 . , 5 . , 4 . , 0 . , 6 . , 8 . , 5 . , 2 . ] , [ 8 . , 5 . , 5 . , 7 . , 1 . , 8 . , 6 . , 7 . , 1 . , 8 . , 1 . , 0 . ] ] ) > > > # Split ` ` 3 > > > np . hsplit ( , 3 ) [ array([[6 . , 7 . , 6 . , 9 . ] , [ 8 . , 5 . , 5 . , 7 . ] ] ) , array([[0 . , 5 . , 4 . , 0 . ] , [ 1 . , 8 . , 6 . , 7 . ] ] ) , array([[6 . , 8 . , 5 . , 2 . ] , [ 1 . , 8 . , 1 . , 0 . ] ] ) ] > > > # Split ` ` fourth column > > > np . hsplit ( , ( 3 , 4 ) ) [ array([[6 . , 7 . , 6 . ] , [ 8 . , 5 . , 5 . ] ] ) , array([[9 . ] , [ 7 . ] ] ) , array([[0 . , 5 . , 4 . , 0 . , 6 . , 8 . , 5 . , 2 . ] , [ 1 . , 8 . , 6 . , 7 . , 1 . , 8 . , 1 . , 0 . ] ] ) ] vsplit splits vertical 
 axis , array_split allows 
 specify axis split . Copies views # operating manipulating arrays , data copied 
 new array . source confusion 
 beginners . cases : copy # Simple assignments copy objects data . > > > = np . array ( [ [ 0 , 1 , 2 , 3 ] , ... [ 4 , 5 , 6 , 7 ] , ... [ 8 , 9 , 10 , 11 ] ] ) > > > b = # new object created > > > b # b names ndarray object True Python passes mutable objects references , function calls 
 copy . > > > def f ( x ): ... print ( d ( x ) ) ... > > > d ( ) # d unique identifier object 148293216   # vary > > > f ( ) 148293216   # vary View shallow copy # Different array objects share data . view method 
 creates new array object looks data . > > > c = . view ( ) > > > c False > > > c . base # c view data owned True > > > c . flags . owndata False > > > > > > c = c . reshape ( ( 2 , 6 ) ) # shape change , reassigned c view > > > . shape ( 3 , 4 ) > > > c [ 0 , 4 ] = 1234 # data changes > > > array ( [ [    0 ,     1 ,     2 ,     3 ] , [ 1234 ,     5 ,     6 ,     7 ] , [    8 ,     9 ,    10 ,    11 ] ] ) Slicing array returns view : > > > s = [: , 1 : 3 ] > > > s [ :] = 10 # s [: ] view s. Note difference s = 10 s [: ] = 10 > > > array ( [ [    0 ,    10 ,    10 ,     3 ] , [ 1234 ,    10 ,    10 ,     7 ] , [    8 ,    10 ,    10 ,    11 ] ] ) Deep copy # copy method makes complete copy array data . > > > d = . copy ( ) # new array object new data created > > > d False > > > d . base # d share False > > > d [ 0 , 0 ] = 9999 > > > array ( [ [    0 ,    10 ,    10 ,     3 ] , [ 1234 ,    10 ,    10 ,     7 ] , [    8 ,    10 ,    10 ,    11 ] ] ) copy called slicing original array required anymore . 
 example , suppose huge intermediate result final result b contains 
 small fraction , deep copy constructing b slicing : > > > = np . arange ( int ( 1e8 ) ) > > > b = [: 100 ] . copy ( ) > > > del # memory ` ` ` ` released . b = a[:100 ] instead , referenced b persist memory 
 del executed . Copies views . Functions methods overview # list useful NumPy functions methods names 
 ordered categories . Routines objects topic list . Array Creation arange , array , copy , , empty_like , eye , fromfile , fromfunction , identity , linspace , logspace , mgrid , ogrid , ones , ones_like , r _ , zeros , zeros_like Conversions ndarray.astype , atleast_1d , atleast_2d , atleast_3d , mat Manipulations array_split , column_stack , concatenate , diagonal , dsplit , dstack , hsplit , hstack , ndarray.item , newaxis , ravel , repeat , reshape , resize , squeeze , swapaxes , , transpose , vsplit , vstack Questions , , nonzero , Ordering argmax , argmin , argsort , max , min , ptp , searchsorted , sort Operations choose , compress , cumprod , cumsum , inner , ndarray.fill , imag , prod , , putmask , real , sum Basic Statistics cov , mean , std , var Basic Linear Algebra cross , dot , outer , linalg.svd , vdot basic # Broadcasting rules # Broadcasting allows universal functions deal meaningful way 
 inputs exactly shape . rule broadcasting input arrays 
 number dimensions , “ 1 ” repeatedly prepended 
 shapes smaller arrays arrays number 
 dimensions . second rule broadcasting ensures arrays size 1 
 particular dimension act size array 
 largest shape dimension . value array 
 element assumed dimension 
 “ broadcast ” array . application broadcasting rules , sizes arrays 
 match . details found Broadcasting . Advanced indexing index tricks # NumPy offers indexing facilities regular Python sequences . 
 addition indexing integers slices , saw , arrays 
 indexed arrays integers arrays booleans . Indexing arrays indices # > > > = np . arange ( 12 ) * * 2 # 12 square numbers > > > = np . array ( [ 1 , 1 , 3 , 8 , 5 ] ) # array indices > > > [ ] # elements ` ` positions ` ` array ( [ 1 ,   1 ,   9 , 64 , 25 ] ) > > > > > > j = np . array ( [ [ 3 , 4 ] , [ 9 , 7 ] ] ) # bidimensional array indices > > > [ j ] # shape ` j ` array ( [ [ 9 , 16 ] , [ 81 , 49 ] ] ) indexed array multidimensional , single array 
 indices refers dimension . following example 
 shows behavior converting image labels color image 
 palette . > > > palette = np . array ( [ [ 0 , 0 , 0 ] , # black ... [ 255 , 0 , 0 ] , # red ... [ 0 , 255 , 0 ] , # green ... [ 0 , 0 , 255 ] , # blue ... [ 255 , 255 , 255 ] ] ) # white > > > image = np . array ( [ [ 0 , 1 , 2 , 0 ] , # value corresponds color palette ... [ 0 , 3 , 4 , 0 ] ] ) > > > palette [ image ] # ( 2 , 4 , 3 ) color image array ( [ [ [   0 ,    0 ,    0 ] , [ 255 ,    0 ,    0 ] , [   0 , 255 ,    0 ] , [   0 ,    0 ,    0 ] ] , [ [   0 ,    0 ,    0 ] , [   0 ,    0 , 255 ] , [ 255 , 255 , 255 ] , [   0 ,    0 ,    0 ] ] ] ) indexes dimension . arrays 
 indices dimension shape . > > > = np . arange ( 12 ) . reshape ( 3 , 4 ) > > > array ( [ [ 0 ,   1 ,   2 ,   3 ] , [ 4 ,   5 ,   6 ,   7 ] , [ 8 ,   9 , 10 , 11 ] ] ) > > > = np . array ( [ [ 0 , 1 ] , # indices dim ` ` ... [ 1 , 2 ] ] ) > > > j = np . array ( [ [ 2 , 1 ] , # indices second dim ... [ 3 , 3 ] ] ) > > > > > > [ , j ] # j equal shape array ( [ [ 2 ,   5 ] , [ 7 , 11 ] ] ) > > > > > > [ , 2 ] array ( [ [ 2 ,   6 ] , [ 6 , 10 ] ] ) > > > > > > [: , j ] array ( [ [ [ 2 ,   1 ] , [ 3 ,   3 ] ] , [ [ 6 ,   5 ] , [ 7 ,   7 ] ] , [ [ 10 ,   9 ] , [ 11 , 11 ] ] ] ) Python , arr[i , j ] exactly arr[(i , j ) ] — 
 j tuple indexing . > > > l = ( , j ) > > > # equivalent a[i , j ] > > > [ l ] array ( [ [ 2 ,   5 ] , [ 7 , 11 ] ] ) , putting j array , 
 array interpreted indexing dimension 
 . > > > s = np . array ( [ , j ] ) > > > # want > > > [ s ] Traceback ( recent ): File " < stdin > " , line 1 , < module > IndexError : index 3 bounds axis 0 size 3 > > > # ` a[i , j ] ` > > > [ tuple ( s ) ] array ( [ [ 2 ,   5 ] , [ 7 , 11 ] ] ) common use indexing arrays search maximum 
 value time - dependent series : > > > time = np . linspace ( 20 , 145 , 5 ) # time scale > > > data = np . sin ( np . arange ( 20 ) ) . reshape ( 5 , 4 ) # 4 time - dependent series > > > time array ( [ 20 .   ,   51.25 ,   82.5 , 113.75 , 145 .   ] ) > > > data array ( [ [ 0 .         ,   0.84147098 ,   0.90929743 ,   0.14112001 ] , [ -0.7568025 , -0.95892427 , -0.2794155 ,   0.6569866 ] , [ 0.98935825 ,   0.41211849 , -0.54402111 , -0.99999021 ] , [ -0.53657292 ,   0.42016704 ,   0.99060736 ,   0.65028784 ] , [ -0.28790332 , -0.96139749 , -0.75098725 ,   0.14987721 ] ] ) > > > # index maxima series > > > ind = data . argmax ( axis = 0 ) > > > ind array([2 , 0 , 3 , 1 ] ) > > > # times corresponding maxima > > > time_max = time [ ind ] > > > > > > data_max = data [ ind , range ( data . shape [ 1 ] ) ] # = > data[ind[0 ] , 0 ] , data[ind[1 ] , 1 ] ... > > > time_max array ( [ 82.5 ,   20 .   , 113.75 ,   51.25 ] ) > > > data_max array([0.98935825 , 0.84147098 , 0.99060736 , 0.6569866 ] ) > > > np . ( data_max = = data . max ( axis = 0 ) ) True use indexing arrays target assign : > > > = np . arange ( 5 ) > > > array([0 , 1 , 2 , 3 , 4 ] ) > > > [ [ 1 , 3 , 4 ] ] = 0 > > > array([0 , 0 , 2 , 0 , 0 ] ) , list indices contains repetitions , assignment 
 times , leaving value : > > > = np . arange ( 5 ) > > > [ [ 0 , 0 , 2 ] ] = [ 1 , 2 , 3 ] > > > array([2 , 1 , 3 , 3 , 4 ] ) reasonable , watch want use Python + = construct , expect : > > > = np . arange ( 5 ) > > > [ [ 0 , 0 , 2 ] ] + = 1 > > > array([1 , 1 , 3 , 3 , 4 ] ) 0 occurs twice list indices , 0th element 
 incremented . Python requires + = 1 
 equivalent = + 1 . Indexing boolean arrays # index arrays arrays ( integer ) indices providing 
 list indices pick . boolean indices approach 
 different ; explicitly choose items array want 
 ones . natural way think boolean indexing use 
 boolean arrays shape original array : > > > = np . arange ( 12 ) . reshape ( 3 , 4 ) > > > b = > 4 > > > b # ` b ` boolean ` ` shape array([[False , False , False , False ] , [ False ,   True ,   True ,   True ] , [ True ,   True ,   True ,   True ] ] ) > > > [ b ] # 1d array selected elements array ( [ 5 ,   6 ,   7 ,   8 ,   9 , 10 , 11 ] ) property useful assignments : > > > [ b ] = 0 # elements ` ` higher 4 0 > > > array([[0 , 1 , 2 , 3 ] , [ 4 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] ] ) look following 
 example 
 use boolean indexing generate image Mandelbrot 
 set : > > > import numpy np > > > import matplotlib.pyplot plt > > > def mandelbrot ( h , w , maxit = 20 , r = 2 ): ... " " " Returns image Mandelbrot fractal size ( h , w ) . " " " ... x = np . linspace ( - 2.5 , 1.5 , 4 * h + 1 ) ... y = np . linspace ( - 1.5 , 1.5 , 3 * w + 1 ) ... , B = np . meshgrid ( x , y ) ... C = + B * 1 j ... z = np . zeros_like ( C ) ... divtime = maxit + np . zeros ( z . shape , dtype = int ) ... ... range ( maxit ): ... z = z * * 2 + C ... diverge = abs ( z ) > r # diverging ... div_now = diverge & ( divtime = = maxit ) # diverging ... divtime [ div_now ] = # note ... z [ diverge ] = r # avoid diverging ... ... return divtime > > > plt . clf ( ) > > > plt . imshow ( mandelbrot ( 400 , 400 ) ) second way indexing booleans similar integer 
 indexing ; dimension array 1D boolean array 
 selecting slices want : > > > = np . arange ( 12 ) . reshape ( 3 , 4 ) > > > b1 = np . array ( [ False , True , True ] ) # dim selection > > > b2 = np . array ( [ True , False , True , False ] ) # second dim selection > > > > > > [ b1 , :] # selecting rows array ( [ [ 4 ,   5 ,   6 ,   7 ] , [ 8 ,   9 , 10 , 11 ] ] ) > > > > > > [ b1 ] # thing array ( [ [ 4 ,   5 ,   6 ,   7 ] , [ 8 ,   9 , 10 , 11 ] ] ) > > > > > > [: , b2 ] # selecting columns array ( [ [ 0 ,   2 ] , [ 4 ,   6 ] , [ 8 , 10 ] ] ) > > > > > > [ b1 , b2 ] # weird thing array ( [ 4 , 10 ] ) Note length 1D boolean array coincide 
 length dimension ( axis ) want slice . previous 
 example , b1 length 3 ( number rows ) , b2 ( length 4 ) suitable index 2nd axis ( columns ) . ix _ ( ) function # ix _ function combine different vectors 
 obtain result n - uplet . example , want compute 
 a+b*c triplets taken vectors , b 
 c : > > > = np . array ( [ 2 , 3 , 4 , 5 ] ) > > > b = np . array ( [ 8 , 5 , 4 ] ) > > > c = np . array ( [ 5 , 4 , 6 , 8 , 3 ] ) > > > ax , bx , cx = np . ix _ ( , b , c ) > > > ax array([[[2 ] ] , [ [ 3 ] ] , [ [ 4 ] ] , [ [ 5 ] ] ] ) > > > bx array([[[8 ] , [ 5 ] , [ 4 ] ] ] ) > > > cx array([[[5 , 4 , 6 , 8 , 3 ] ] ] ) > > > ax . shape , bx . shape , cx . shape ( ( 4 , 1 , 1 ) , ( 1 , 3 , 1 ) , ( 1 , 1 , 5 ) ) > > > result = ax + bx * cx > > > result array([[[42 , 34 , 50 , 66 , 26 ] , [ 27 , 22 , 32 , 42 , 17 ] , [ 22 , 18 , 26 , 34 , 14 ] ] , [ [ 43 , 35 , 51 , 67 , 27 ] , [ 28 , 23 , 33 , 43 , 18 ] , [ 23 , 19 , 27 , 35 , 15 ] ] , [ [ 44 , 36 , 52 , 68 , 28 ] , [ 29 , 24 , 34 , 44 , 19 ] , [ 24 , 20 , 28 , 36 , 16 ] ] , [ [ 45 , 37 , 53 , 69 , 29 ] , [ 30 , 25 , 35 , 45 , 20 ] , [ 25 , 21 , 29 , 37 , 17 ] ] ] ) > > > result [ 3 , 2 , 4 ] 17 > > > [ 3 ] + b [ 2 ] * c [ 4 ] 17 implement reduce follows : > > > def ufunc_reduce ( ufct , * vectors ): ... vs = np . ix _ ( * vectors ) ... r = ufct . identity ... v vs : ... r = ufct ( r , v ) ... return r use : > > > ufunc_reduce ( np . add , , b , c ) array([[[15 , 14 , 16 , 18 , 13 ] , [ 12 , 11 , 13 , 15 , 10 ] , [ 11 , 10 , 12 , 14 ,   9 ] ] , [ [ 16 , 15 , 17 , 19 , 14 ] , [ 13 , 12 , 14 , 16 , 11 ] , [ 12 , 11 , 13 , 15 , 10 ] ] , [ [ 17 , 16 , 18 , 20 , 15 ] , [ 14 , 13 , 15 , 17 , 12 ] , [ 13 , 12 , 14 , 16 , 11 ] ] , [ [ 18 , 17 , 19 , 21 , 16 ] , [ 15 , 14 , 16 , 18 , 13 ] , [ 14 , 13 , 15 , 17 , 12 ] ] ] ) advantage version reduce compared normal 
 ufunc.reduce makes use broadcasting rules order avoid creating argument array size output 
 times number vectors . Indexing strings # Structured arrays . Tricks tips # list short useful tips . “ Automatic ” reshaping # change dimensions array , omit sizes 
 deduced automatically : > > > = np . arange ( 30 ) > > > b = . reshape ( ( 2 , - 1 , 3 ) ) # -1 means " needed " > > > b . shape ( 2 , 5 , 3 ) > > > b array ( [ [ [ 0 ,   1 ,   2 ] , [ 3 ,   4 ,   5 ] , [ 6 ,   7 ,   8 ] , [ 9 , 10 , 11 ] , [ 12 , 13 , 14 ] ] , [ [ 15 , 16 , 17 ] , [ 18 , 19 , 20 ] , [ 21 , 22 , 23 ] , [ 24 , 25 , 26 ] , [ 27 , 28 , 29 ] ] ] ) Vector stacking # construct 2D array list equally - sized row vectors ? 
 MATLAB easy : x y vectors 
 length need m=[x;y ] . NumPy works 
 functions column_stack , dstack , hstack vstack , 
 depending dimension stacking . 
 example : > > > x = np . arange ( 0 , 10 , 2 ) > > > y = np . arange ( 5 ) > > > m = np . vstack ( [ x , y ] ) > > > m array([[0 , 2 , 4 , 6 , 8 ] , [ 0 , 1 , 2 , 3 , 4 ] ] ) > > > xy = np . hstack ( [ x , y ] ) > > > xy array([0 , 2 , 4 , 6 , 8 , 0 , 1 , 2 , 3 , 4 ] ) logic functions dimensions 
 strange . NumPy MATLAB users Histograms # NumPy histogram function applied array returns pair 
 vectors : histogram array vector bin edges . Beware : matplotlib function build histograms ( called hist , 
 Matlab ) differs NumPy . main difference 
 pylab.hist plots histogram automatically , numpy.histogram generates data . > > > import numpy np > > > rg = np . random . default_rng ( 1 ) > > > import matplotlib.pyplot plt > > > # Build vector 10000 normal deviates variance 0.5 ^ 2 mean 2 > > > mu , sigma = 2 , 0.5 > > > v = rg . normal ( mu , sigma , 10000 ) > > > # Plot normalized histogram 50 bins > > > plt . hist ( v , bins = 50 , density = True ) # matplotlib version ( plot ) ( array ... ) > > > # Compute histogram numpy plot > > > ( n , bins ) = np . histogram ( v , bins = 50 , density = True ) # NumPy version ( plot ) > > > plt . plot ( .5 * ( bins [ 1 :] + bins [: - 1 ] ) , n ) Matplotlib > = 3.4 use plt.stairs(n , bins ) . reading # Python tutorial NumPy reference SciPy Tutorial SciPy Lecture Notes matlab , R , IDL , NumPy / SciPy dictionary tutorial - svd previous NumPy ? NumPy : absolute basics beginners page Prerequisites basics example Array creation Printing arrays Basic operations Universal functions Indexing , slicing iterating Shape manipulation Changing shape array Stacking different arrays Splitting array smaller ones Copies views copy View shallow copy Deep copy Functions methods overview basic Broadcasting rules Advanced indexing index tricks Indexing arrays indices Indexing boolean arrays ix _ ( ) function Indexing strings Tricks tips “ Automatic ” reshaping Vector stacking Histograms reading © Copyright 2008 - 2024 , NumPy Developers . Created Sphinx 7.2.6 . Built PyData Sphinx Theme 0.16.0 .