NumPy : absolute basics beginners — NumPy v2.2 Manual Skip main content Ctrl + K User Guide API reference Building source Development Release notes Learn NEPs Choose version GitHub User Guide API reference Building source Development Release notes Learn NEPs Choose version GitHub Section Navigation Getting started NumPy ? Installation NumPy quickstart NumPy : absolute basics beginners Fundamentals usage NumPy fundamentals NumPy MATLAB users NumPy tutorials NumPy - tos Advanced usage interoperability NumPy C - API F2PY user guide reference manual - - hood documentation developers Interoperability NumPy Extras Glossary Release notes NumPy 2.0 migration guide NumPy license NumPy user guide NumPy : absolute basics beginners NumPy : absolute basics beginners # Welcome absolute beginner guide NumPy ! NumPy ( Num erical Py thon ) open source Python library 
 widely science engineering . NumPy library contains 
 multidimensional array data structures , homogeneous , N - dimensional ndarray , large library functions operate efficiently 
 data structures . Learn NumPy NumPy , 
 comments suggestions , reach ! import NumPy # installing NumPy , imported 
 Python code like : import numpy np widespread convention allows access NumPy features short , 
 recognizable prefix ( np . ) distinguishing NumPy features 
 . Reading example code # NumPy documentation , find blocks look like : > > > = np . array ( [ [ 1 , 2 , 3 ] , ... [ 4 , 5 , 6 ] ] ) > > > . shape ( 2 , 3 ) Text preceded > > > ... input , code 
 enter script Python prompt . output , 
 results running code . Note > > > ... 
 code cause error entered Python prompt . use NumPy ? # Python lists excellent , general - purpose containers . 
 “ heterogeneous ” , meaning contain elements variety types , 
 fast perform individual operations handful 
 elements . Depending characteristics data types operations 
 need performed , containers appropriate ; exploiting 
 characteristics , improve speed , reduce memory consumption , 
 offer high - level syntax performing variety common processing tasks . 
 NumPy shines large quantities “ homogeneous ” ( - type ) data 
 processed CPU . “ array ” ? # computer programming , array structure storing retrieving 
 data . talk array grid space , 
 cell storing element data . instance , element 
 data number , visualize “ - dimensional ” array like 
 list : \[\begin{split}\begin{array}{|c||c|c|c| } 
 \hline 
 1 & 5 & 2 & 0 \\ 
 \hline 
 \end{array}\end{split}\ ] - dimensional array like table : \[\begin{split}\begin{array}{|c||c|c|c| } 
 \hline 
 1 & 5 & 2 & 0 \\ 
 \hline 
 8 & 3 & 6 & 1 \\ 
 \hline 
 1 & 7 & 2 & 9 \\ 
 \hline 
 \end{array}\end{split}\ ] - dimensional array like set tables , stacked 
 printed separate pages . NumPy , idea 
 generalized arbitrary number dimensions , fundamental 
 array class called ndarray : represents “ N - dimensional 
 array ” . NumPy arrays restrictions . instance : elements array type data . created , total size array change . shape “ rectangular ” , “ jagged ” ; e.g. , row 
 - dimensional array number columns . conditions met , NumPy exploits characteristics 
 array faster , memory efficient , convenient use 
 restrictive data structures . remainder document , use word “ array ” refer 
 instance ndarray . Array fundamentals # way initialize array Python sequence , list . 
 example : > > > = np . array ( [ 1 , 2 , 3 , 4 , 5 , 6 ] ) > > > array([1 , 2 , 3 , 4 , 5 , 6 ] ) Elements array accessed ways . instance , access 
 individual element array access element original 
 list : integer index element square brackets . > > > [ 0 ] 1 Note built - Python sequences , NumPy arrays “ 0 - indexed ” : 
 element array accessed index 0 , 1 . Like original list , array mutable . > > > [ 0 ] = 10 > > > array([10 ,   2 ,   3 ,   4 ,   5 ,   6 ] ) like original list , Python slice notation indexing . > > > [: 3 ] array([10 , 2 , 3 ] ) major difference slice indexing list copies elements 
 new list , slicing array returns view : object refers 
 data original array . original array mutated view . > > > b = [ 3 :] > > > b array([4 , 5 , 6 ] ) > > > b [ 0 ] = 40 > > > array ( [ 10 ,   2 ,   3 , 40 ,   5 ,   6 ] ) Copies views comprehensive explanation 
 array operations return views copies . Two- higher - dimensional arrays initialized nested Python 
 sequences : > > > = np . array ( [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 9 , 10 , 11 , 12 ] ] ) > > > array ( [ [ 1 ,   2 ,   3 ,   4 ] , [ 5 ,   6 ,   7 ,   8 ] , [ 9 , 10 , 11 , 12 ] ] ) NumPy , dimension array referred “ axis ” . 
 terminology useful disambiguate dimensionality 
 array dimensionality data represented array . 
 instance , array represent points , lying 
 - dimensional space , “ axes ” . difference array list lists 
 element array accessed specifying index 
 axis single set square brackets , separated commas . 
 instance , element 8 row 1 column 3 : > > > [ 1 , 3 ] 8 Note familiar practice mathematics refer elements matrix 
 row index column index second . happens true 
 - dimensional arrays , better mental model think 
 column index coming row index second . 
 generalizes arrays number dimensions . Note hear 0 - D ( zero - dimensional ) array referred “ scalar ” , 
 1 - D ( - dimensional ) array “ vector ” , 2 - D ( - dimensional ) array 
 “ matrix ” , N - D ( N - dimensional , “ N ” typically integer 
 greater 2 ) array “ tensor ” . clarity , best avoid 
 mathematical terms referring array mathematical 
 objects names behave differently arrays ( e.g. “ matrix ” 
 multiplication fundamentally different “ array ” multiplication ) , 
 objects scientific Python ecosystem 
 names ( e.g. fundamental data structure PyTorch “ tensor ” ) . Array attributes # section covers ndim , shape , size , dtype attributes array . number dimensions array contained ndim attribute . > > > . ndim 2 shape array tuple non - negative integers specify 
 number elements dimension . > > > . shape ( 3 , 4 ) > > > len ( . shape ) = = . ndim True fixed , total number elements array contained size attribute . > > > . size 12 > > > import math > > > . size = = math . prod ( . shape ) True Arrays typically “ homogeneous ” , meaning contain elements 
 “ data type ” . data type recorded dtype attribute . > > > . dtype dtype('int64 ' )   # " int " integer , " 64 " 64 - bit Read array attributes learn array objects . create basic array # section covers np.zeros ( ) , np.ones ( ) , np.empty ( ) , np.arange ( ) , np.linspace ( ) creating array sequence elements , easily create 
 array filled 0 : > > > np . zeros ( 2 ) array([0 . , 0 . ] ) array filled 1 : > > > np . ones ( 2 ) array([1 . , 1 . ] ) array ! function creates array initial 
 content random depends state memory . reason use zeros ( similar ) speed - sure 
 fill element ! > > > # Create array 2 elements > > > np . ( 2 ) array([3.14 , 42 .   ] )   # vary create array range elements : > > > np . arange ( 4 ) array([0 , 1 , 2 , 3 ] ) array contains range evenly spaced intervals . , 
 specify number , number , step size . > > > np . arange ( 2 , 9 , 2 ) array([2 , 4 , 6 , 8 ] ) use np.linspace ( ) create array values 
 spaced linearly specified interval : > > > np . linspace ( 0 , 10 , num = 5 ) array ( [ 0 . ,   2.5 ,   5 . ,   7.5 , 10 . ] ) Specifying data type default data type floating point ( np.float64 ) , explicitly 
 specify data type want dtype keyword . > > > x = np . ones ( 2 , dtype = np . int64 ) > > > x array([1 , 1 ] ) Learn creating arrays Adding , removing , sorting elements # section covers np.sort ( ) , np.concatenate ( ) Sorting array simple np.sort ( ) . specify axis , kind , 
 order function . start array : > > > arr = np . array ( [ 2 , 1 , 5 , 3 , 7 , 4 , 6 , 8 ] ) quickly sort numbers ascending order : > > > np . sort ( arr ) array([1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] ) addition sort , returns sorted copy array , use : argsort , indirect sort specified axis , lexsort , indirect stable sort multiple keys , searchsorted , find elements sorted array , partition , partial sort . read sorting array , : sort . start arrays : > > > = np . array ( [ 1 , 2 , 3 , 4 ] ) > > > b = np . array ( [ 5 , 6 , 7 , 8 ] ) concatenate np.concatenate ( ) . > > > np . concatenate ( ( , b ) ) array([1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] ) , start arrays : > > > x = np . array ( [ [ 1 , 2 ] , [ 3 , 4 ] ] ) > > > y = np . array ( [ [ 5 , 6 ] ] ) concatenate : > > > np . concatenate ( ( x , y ) , axis = 0 ) array([[1 , 2 ] , [ 3 , 4 ] , [ 5 , 6 ] ] ) order remove elements array , simple use indexing select 
 elements want . read concatenate , : concatenate . know shape size array ? # section covers ndarray.ndim , ndarray.size , ndarray.shape ndarray.ndim tell number axes , dimensions , array . ndarray.size tell total number elements array . 
 product elements array shape . ndarray.shape display tuple integers indicate number 
 elements stored dimension array . , example , 
 2 - D array 2 rows 3 columns , shape array ( 2 , 3 ) . example , create array : > > > array_example = np . array ( [ [ [ 0 , 1 , 2 , 3 ] , ... [ 4 , 5 , 6 , 7 ] ] , ... ... [ [ 0 , 1 , 2 , 3 ] , ... [ 4 , 5 , 6 , 7 ] ] , ... ... [ [ 0 , 1 , 2 , 3 ] , ... [ 4 , 5 , 6 , 7 ] ] ] ) find number dimensions array , run : > > > array_example . ndim 3 find total number elements array , run : > > > array_example . size 24 find shape array , run : > > > array_example . shape ( 3 , 2 , 4 ) reshape array ? # section covers arr.reshape ( ) Yes ! arr.reshape ( ) new shape array changing 
 data . remember use reshape method , array want 
 produce needs number elements original array . 
 start array 12 elements , need sure new 
 array total 12 elements . start array : > > > = np . arange ( 6 ) > > > print ( ) [ 0 1 2 3 4 5 ] use reshape ( ) reshape array . example , reshape 
 array array rows columns : > > > b = . reshape ( 3 , 2 ) > > > print ( b ) [ [ 0 1 ] [ 2 3 ] [ 4 5 ] ] np.reshape , specify optional parameters : > > > np . reshape ( , shape = ( 1 , 6 ) , order = ' C ' ) array([[0 , 1 , 2 , 3 , 4 , 5 ] ] ) array reshaped . shape new shape want . specify integer tuple 
 integers . specify integer , result array length . 
 shape compatible original shape . order : C means read / write elements C - like index order , F means read / write elements Fortran - like index order , means read / write elements Fortran - like index order Fortran 
 contiguous memory , C - like order . ( optional parameter 
 need specified . ) want learn C Fortran order , read internal organization NumPy arrays . 
 Essentially , C Fortran orders indices correspond 
 order array stored memory . Fortran , moving 
 elements - dimensional array stored memory , index rapidly varying index . index moves 
 row changes , matrix stored column time . 
 Fortran thought Column - major language . 
 C hand , index changes 
 rapidly . matrix stored rows , making Row - major 
 language . C Fortran depends important 
 preserve indexing convention reorder data . Learn shape manipulation . convert 1D array 2D array ( add new axis array ) # section covers np.newaxis , np.expand_dims use np.newaxis np.expand_dims increase dimensions 
 existing array . np.newaxis increase dimensions array dimension 
 . means 1D array 2D array , 2D array 3D array , . example , start array : > > > = np . array ( [ 1 , 2 , 3 , 4 , 5 , 6 ] ) > > > . shape ( 6 , ) use np.newaxis add new axis : > > > a2 = [ np . newaxis , :] > > > a2 . shape ( 1 , 6 ) explicitly convert 1D array row vector column 
 vector np.newaxis . example , convert 1D array row 
 vector inserting axis dimension : > > > row_vector = [ np . newaxis , :] > > > row_vector . shape ( 1 , 6 ) , column vector , insert axis second dimension : > > > col_vector = [: , np . newaxis ] > > > col_vector . shape ( 6 , 1 ) expand array inserting new axis specified position 
 np.expand_dims . example , start array : > > > = np . array ( [ 1 , 2 , 3 , 4 , 5 , 6 ] ) > > > . shape ( 6 , ) use np.expand_dims add axis index position 1 : > > > b = np . expand_dims ( , axis = 1 ) > > > b . shape ( 6 , 1 ) add axis index position 0 : > > > c = np . expand_dims ( , axis = 0 ) > > > c . shape ( 1 , 6 ) Find information newaxis expand_dims expand_dims . Indexing slicing # index slice NumPy arrays ways slice Python 
 lists . > > > data = np . array ( [ 1 , 2 , 3 ] ) > > > data [ 1 ] 2 > > > data [ 0 : 2 ] array([1 , 2 ] ) > > > data [ 1 :] array([2 , 3 ] ) > > > data [ - 2 :] array([2 , 3 ] ) visualize way : want section array specific array elements use 
 analysis additional operations . , need subset , 
 slice , and/or index arrays . want select values array fulfill certain conditions , 
 straightforward NumPy . example , start array : > > > = np . array ( [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 9 , 10 , 11 , 12 ] ] ) easily print values array 5 . > > > print ( [ < 5 ] ) [ 1 2 3 4 ] select , example , numbers equal greater 5 , 
 use condition index array . > > > five_up = ( > = 5 ) > > > print ( [ five_up ] ) [ 5   6   7   8   9 10 11 12 ] select elements divisible 2 : > > > divisible_by_2 = [ % 2 = = 0 ] > > > print ( divisible_by_2 ) [ 2   4   6   8 10 12 ] select elements satisfy conditions & | operators : > > > c = [ ( > 2 ) & ( < 11 ) ] > > > print ( c ) [ 3   4   5   6   7   8   9 10 ] use logical operators & | order 
 return boolean values specify values array fulfill 
 certain condition . useful arrays contain names 
 categorical values . > > > five_up = ( > 5 ) | ( = = 5 ) > > > print ( five_up ) [ [ False False False False ] [ True   True   True   True ] [ True   True   True True ] ] use np.nonzero ( ) select elements indices array . Starting array : > > > = np . array ( [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 9 , 10 , 11 , 12 ] ] ) use np.nonzero ( ) print indices elements , 
 example , 5 : > > > b = np . nonzero ( < 5 ) > > > print ( b ) ( array([0 , 0 , 0 , 0 ] ) , array([0 , 1 , 2 , 3 ] ) ) example , tuple arrays returned : dimension . 
 array represents row indices values found , 
 second array represents column indices values found . want generate list coordinates elements exist , 
 zip arrays , iterate list coordinates , print . 
 example : > > > list_of_coordinates = list ( zip ( b [ 0 ] , b [ 1 ] ) ) > > > coord list_of_coordinates : ... print ( coord ) ( np.int64(0 ) , np.int64(0 ) ) ( np.int64(0 ) , np.int64(1 ) ) ( np.int64(0 ) , np.int64(2 ) ) ( np.int64(0 ) , np.int64(3 ) ) use np.nonzero ( ) print elements array 
 5 : > > > print ( [ b ] ) [ 1 2 3 4 ] element looking exist array , returned 
 array indices . example : > > > not_there = np . nonzero ( = = 42 ) > > > print ( not_there ) ( array ( [ ] , dtype = int64 ) , array ( [ ] , dtype = int64 ) ) Learn indexing slicing . Read nonzero function : nonzero . create array existing data # section covers slicing indexing , np.vstack ( ) , np.hstack ( ) , np.hsplit ( ) , .view ( ) , copy ( ) easily create new array section existing array . Let array : > > > = np . array ( [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] ) create new array section array time specifying 
 want slice array . > > > arr1 = [ 3 : 8 ] > > > arr1 array([4 , 5 , 6 , 7 , 8 ] ) , grabbed section array index position 3 index 
 position 8 including position 8 . Reminder : Array indexes begin 0 . means element array index 0 , 
 second element index 1 , . stack existing arrays , vertically horizontally . Let 
 arrays , a1 a2 : > > > a1 = np . array ( [ [ 1 , 1 ] , ... [ 2 , 2 ] ] ) > > > a2 = np . array ( [ [ 3 , 3 ] , ... [ 4 , 4 ] ] ) stack vertically vstack : > > > np . vstack ( ( a1 , a2 ) ) array([[1 , 1 ] , [ 2 , 2 ] , [ 3 , 3 ] , [ 4 , 4 ] ] ) stack horizontally hstack : > > > np . hstack ( ( a1 , a2 ) ) array([[1 , 1 , 3 , 3 ] , [ 2 , 2 , 4 , 4 ] ] ) split array smaller arrays hsplit . 
 specify number equally shaped arrays return columns division occur . Let array : > > > x = np . arange ( 1 , 25 ) . reshape ( 2 , 12 ) > > > x array ( [ [ 1 ,   2 ,   3 ,   4 ,   5 ,   6 ,   7 ,   8 ,   9 , 10 , 11 , 12 ] , [ 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 ] ] ) wanted split array equally shaped arrays , 
 run : > > > np . hsplit ( x , 3 ) [ array ( [ [ 1 ,   2 ,   3 ,   4 ] , [ 13 , 14 , 15 , 16 ] ] ) , array ( [ [ 5 ,   6 ,   7 ,   8 ] , [ 17 , 18 , 19 , 20 ] ] ) , array ( [ [ 9 , 10 , 11 , 12 ] , [ 21 , 22 , 23 , 24 ] ] ) ] wanted split array fourth column , run : > > > np . hsplit ( x , ( 3 , 4 ) ) [ array ( [ [ 1 ,   2 ,   3 ] , [ 13 , 14 , 15 ] ] ) , array ( [ [ 4 ] , [ 16 ] ] ) , array ( [ [ 5 ,   6 ,   7 ,   8 ,   9 , 10 , 11 , 12 ] , [ 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 ] ] ) ] Learn stacking splitting arrays . use view method create new array object looks 
 data original array ( shallow copy ) . Views important NumPy concept ! NumPy functions , operations 
 like indexing slicing , return views possible . saves 
 memory faster ( copy data ) . 
 important aware - modifying data view modifies 
 original array ! Let create array : > > > = np . array ( [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 9 , 10 , 11 , 12 ] ] ) create array b1 slicing modify element b1 . modify corresponding element ! > > > b1 = [ 0 , :] > > > b1 array([1 , 2 , 3 , 4 ] ) > > > b1 [ 0 ] = 99 > > > b1 array([99 ,   2 ,   3 ,   4 ] ) > > > array([[99 ,   2 ,   3 ,   4 ] , [ 5 ,   6 ,   7 ,   8 ] , [ 9 , 10 , 11 , 12 ] ] ) copy method complete copy array data ( deep copy ) . use array , run : > > > b2 = . copy ( ) Learn copies views . Basic array operations # section covers addition , subtraction , multiplication , division , created arrays , start work .   Let , 
 example , created arrays , called “ data ” called 
 “ ones ” add arrays plus sign . > > > data = np . array ( [ 1 , 2 ] ) > > > ones = np . ones ( 2 , dtype = int ) > > > data + ones array([2 , 3 ] ) , course , addition ! > > > data - ones array([0 , 1 ] ) > > > data * data array([1 , 4 ] ) > > > data / data array([1 . , 1 . ] ) Basic operations simple NumPy . want find sum 
 elements array , use sum ( ) . works 1D arrays , 2D arrays , 
 arrays higher dimensions . > > > = np . array ( [ 1 , 2 , 3 , 4 ] ) > > > . sum ( ) 10 add rows columns 2D array , specify axis . start array : > > > b = np . array ( [ [ 1 , 1 ] , [ 2 , 2 ] ] ) sum axis rows : > > > b . sum ( axis = 0 ) array([3 , 3 ] ) sum axis columns : > > > b . sum ( axis = 1 ) array([2 , 4 ] ) Learn basic operations . Broadcasting # times want carry operation array 
 single number ( called operation vector scalar ) 
 arrays different sizes . example , array ( 
 “ data ” ) contain information distance miles want 
 convert information kilometers . perform operation : > > > data = np . array ( [ 1.0 , 2.0 ] ) > > > data * 1.6 array([1.6 , 3.2 ] ) NumPy understands multiplication happen cell . 
 concept called broadcasting . Broadcasting mechanism allows 
 NumPy perform operations arrays different shapes . dimensions 
 array compatible , example , dimensions arrays 
 equal 1 . dimensions compatible , 
 ValueError . Learn broadcasting . useful array operations # section covers maximum , minimum , sum , mean , product , standard deviation , NumPy performs aggregation functions . addition min , max , sum , easily run mean average , prod 
 result multiplying elements , std standard 
 deviation , . > > > data . max ( ) 2.0 > > > data . min ( ) 1.0 > > > data . sum ( ) 3.0 Let start array , called “ ” > > > = np . array ( [ [ 0.45053314 , 0.17296777 , 0.34376245 , 0.5510652 ] , ... [ 0.54627315 , 0.05093587 , 0.40067661 , 0.55645993 ] , ... [ 0.12697628 , 0.82485143 , 0.26590556 , 0.56917101 ] ] ) common want aggregate row column . default , 
 NumPy aggregation function return aggregate entire array . 
 find sum minimum elements array , run : > > > . sum ( ) 4.8595784 : > > > . min ( ) 0.05093587 specify axis want aggregation function computed . 
 example , find minimum value column specifying axis=0 . > > > . min ( axis = 0 ) array([0.12697628 , 0.05093587 , 0.26590556 , 0.5510652 ] ) values listed correspond number columns array . 
 - column array , values result . Read array methods . Creating matrices # pass Python lists lists create 2 - D array ( “ matrix ” ) 
 represent NumPy . > > > data = np . array ( [ [ 1 , 2 ] , [ 3 , 4 ] , [ 5 , 6 ] ] ) > > > data array([[1 , 2 ] , [ 3 , 4 ] , [ 5 , 6 ] ] ) Indexing slicing operations useful manipulating matrices : > > > data [ 0 , 1 ] 2 > > > data [ 1 : 3 ] array([[3 , 4 ] , [ 5 , 6 ] ] ) > > > data [ 0 : 2 , 0 ] array([1 , 3 ] ) aggregate matrices way aggregated vectors : > > > data . max ( ) 6 > > > data . min ( ) 1 > > > data . sum ( ) 21 aggregate values matrix aggregate 
 columns rows axis parameter . illustrate point , let 
 look slightly modified dataset : > > > data = np . array ( [ [ 1 , 2 ] , [ 5 , 3 ] , [ 4 , 6 ] ] ) > > > data array([[1 , 2 ] , [ 5 , 3 ] , [ 4 , 6 ] ] ) > > > data . max ( axis = 0 ) array([5 , 6 ] ) > > > data . max ( axis = 1 ) array([2 , 5 , 6 ] ) created matrices , add multiply 
 arithmetic operators matrices size . > > > data = np . array ( [ [ 1 , 2 ] , [ 3 , 4 ] ] ) > > > ones = np . array ( [ [ 1 , 1 ] , [ 1 , 1 ] ] ) > > > data + ones array([[2 , 3 ] , [ 4 , 5 ] ] ) arithmetic operations matrices different sizes , 
 matrix column row . case , NumPy use 
 broadcast rules operation . > > > data = np . array ( [ [ 1 , 2 ] , [ 3 , 4 ] , [ 5 , 6 ] ] ) > > > ones_row = np . array ( [ [ 1 , 1 ] ] ) > > > data + ones_row array([[2 , 3 ] , [ 4 , 5 ] , [ 6 , 7 ] ] ) aware NumPy prints N - dimensional arrays , axis looped 
 fastest axis slowest . instance : > > > np . ones ( ( 4 , 3 , 2 ) ) array([[[1 . , 1 . ] , [ 1 . , 1 . ] , [ 1 . , 1 . ] ] , [ [ 1 . , 1 . ] , [ 1 . , 1 . ] , [ 1 . , 1 . ] ] , [ [ 1 . , 1 . ] , [ 1 . , 1 . ] , [ 1 . , 1 . ] ] , [ [ 1 . , 1 . ] , [ 1 . , 1 . ] , [ 1 . , 1 . ] ] ] ) instances want NumPy initialize values 
 array . NumPy offers functions like ones ( ) zeros ( ) , random . Generator class random number generation . 
 need pass number elements want generate : > > > np . ones ( 3 ) array([1 . , 1 . , 1 . ] ) > > > np . zeros ( 3 ) array([0 . , 0 . , 0 . ] ) > > > rng = np . random . default_rng ( ) # simplest way generate random numbers > > > rng . random ( 3 ) array([0.63696169 , 0.26978671 , 0.04097352 ] ) use ones ( ) , zeros ( ) , random ( ) create 
 2D array tuple describing dimensions matrix : > > > np . ones ( ( 3 , 2 ) ) array([[1 . , 1 . ] , [ 1 . , 1 . ] , [ 1 . , 1 . ] ] ) > > > np . zeros ( ( 3 , 2 ) ) array([[0 . , 0 . ] , [ 0 . , 0 . ] , [ 0 . , 0 . ] ] ) > > > rng . random ( ( 3 , 2 ) ) array([[0.01652764 , 0.81327024 ] , [ 0.91275558 , 0.60663578 ] , [ 0.72949656 , 0.54362499 ] ] )   # vary Read creating arrays , filled 0 , 1 , values 
 uninitialized , array creation routines . Generating random numbers # use random number generation important configuration 
 evaluation numerical machine learning algorithms . 
 need randomly initialize weights artificial neural network , split data 
 random sets , randomly shuffle dataset , able generate 
 random numbers ( actually , repeatable pseudo - random numbers ) essential . Generator.integers , generate random integers low ( remember 
 inclusive NumPy ) high ( exclusive ) . set endpoint = True high number inclusive . generate 2 x 4 array random integers 0 4 : > > > rng . integers ( 5 , size = ( 2 , 4 ) ) array([[2 , 1 , 1 , 0 ] , [ 0 , 0 , 0 , 4 ] ] )   # vary Read random number generation . unique items counts # section covers np.unique ( ) find unique elements array easily np.unique . example , start array : > > > = np . array ( [ 11 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 12 , 13 , 11 , 14 , 18 , 19 , 20 ] ) use np.unique print unique values array : > > > unique_values = np . unique ( ) > > > print ( unique_values ) [ 11 12 13 14 15 16 17 18 19 20 ] indices unique values NumPy array ( array index 
 positions unique values array ) , pass return_index argument np.unique ( ) array . > > > unique_values , indices_list = np . unique ( , return_index = True ) > > > print ( indices_list ) [ 0   2   3   4   5   6   7 12 13 14 ] pass return_counts argument np.unique ( ) 
 array frequency count unique values NumPy array . > > > unique_values , occurrence_count = np . unique ( , return_counts = True ) > > > print ( occurrence_count ) [ 3 2 2 2 1 1 1 1 1 1 ] works 2D arrays ! 
 start array : > > > a_2d = np . array ( [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 9 , 10 , 11 , 12 ] , [ 1 , 2 , 3 , 4 ] ] ) find unique values : > > > unique_values = np . unique ( a_2d ) > > > print ( unique_values ) [ 1   2   3   4   5   6   7   8   9 10 11 12 ] axis argument passed , 2D array flattened . want unique rows columns , sure pass axis argument . find unique rows , specify axis=0 columns , specify axis=1 . > > > unique_rows = np . unique ( a_2d , axis = 0 ) > > > print ( unique_rows ) [ [ 1   2   3   4 ] [ 5   6   7   8 ] [ 9 10 11 12 ] ] unique rows , index position , occurrence count , use : > > > unique_rows , indices , occurrence_count = np . unique ( ... a_2d , axis = 0 , return_counts = True , return_index = True ) > > > print ( unique_rows ) [ [ 1   2   3   4 ] [ 5   6   7   8 ] [ 9 10 11 12 ] ] > > > print ( indices ) [ 0 1 2 ] > > > print ( occurrence_count ) [ 2 1 1 ] learn finding unique elements array , unique . Transposing reshaping matrix # section covers arr.reshape ( ) , arr.transpose ( ) , arr . T common need transpose matrices . NumPy arrays property T allows transpose matrix . need switch dimensions matrix . happen , 
 example , model expects certain input shape 
 different dataset . reshape method useful . 
 simply need pass new dimensions want matrix . > > > data . reshape ( 2 , 3 ) array([[1 , 2 , 3 ] , [ 4 , 5 , 6 ] ] ) > > > data . reshape ( 3 , 2 ) array([[1 , 2 ] , [ 3 , 4 ] , [ 5 , 6 ] ] ) use .transpose ( ) reverse change axes array 
 according values specify . start array : > > > arr = np . arange ( 6 ) . reshape ( ( 2 , 3 ) ) > > > arr array([[0 , 1 , 2 ] , [ 3 , 4 , 5 ] ] ) transpose array arr.transpose ( ) . > > > arr . transpose ( ) array([[0 , 3 ] , [ 1 , 4 ] , [ 2 , 5 ] ] ) use arr . T : > > > arr . T array([[0 , 3 ] , [ 1 , 4 ] , [ 2 , 5 ] ] ) learn transposing reshaping arrays , transpose reshape . reverse array # section covers np.flip ( ) NumPy np.flip ( ) function allows flip , reverse , contents 
 array axis . np.flip ( ) , specify array like 
 reverse axis . specify axis , NumPy reverse 
 contents axes input array . Reversing 1D array begin 1D array like : > > > arr = np . array ( [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] ) reverse : > > > reversed_arr = np . flip ( arr ) want print reversed array , run : > > > print ( ' Reversed Array : ' , reversed_arr ) Reversed Array :   [ 8 7 6 5 4 3 2 1 ] Reversing 2D array 2D array works way . start array : > > > arr_2d = np . array ( [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 9 , 10 , 11 , 12 ] ] ) reverse content rows columns : > > > reversed_arr = np . flip ( arr_2d ) > > > print ( reversed_arr ) [ [ 12 11 10   9 ] [ 8   7   6   5 ] [ 4   3   2   1 ] ] easily reverse rows : > > > reversed_arr_rows = np . flip ( arr_2d , axis = 0 ) > > > print ( reversed_arr_rows ) [ [ 9 10 11 12 ] [ 5   6   7   8 ] [ 1   2   3   4 ] ] reverse columns : > > > reversed_arr_columns = np . flip ( arr_2d , axis = 1 ) > > > print ( reversed_arr_columns ) [ [ 4   3   2   1 ] [ 8   7   6   5 ] [ 12 11 10   9 ] ] reverse contents column row . example , 
 reverse contents row index position 1 ( second row ): > > > arr_2d [ 1 ] = np . flip ( arr_2d [ 1 ] ) > > > print ( arr_2d ) [ [ 1   2   3   4 ] [ 8   7   6   5 ] [ 9 10 11 12 ] ] reverse column index position 1 ( second column ): > > > arr_2d [: , 1 ] = np . flip ( arr_2d [: , 1 ] ) > > > print ( arr_2d ) [ [ 1 10   3   4 ] [ 8   7   6   5 ] [ 9   2 11 12 ] ] Read reversing arrays flip . Reshaping flattening multidimensional arrays # section covers .flatten ( ) , ravel ( ) popular ways flatten array : .flatten ( ) .ravel ( ) . 
 primary difference new array created ravel ( ) actually reference parent array ( i.e. , “ view ” ) . 
 means changes new array affect parent array . 
 ravel create copy , memory efficient . start array : > > > x = np . array ( [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 9 , 10 , 11 , 12 ] ] ) use flatten flatten array 1D array . > > > x . flatten ( ) array ( [ 1 ,   2 ,   3 ,   4 ,   5 ,   6 ,   7 ,   8 ,   9 , 10 , 11 , 12 ] ) use flatten , changes new array wo change parent 
 array . example : > > > a1 = x . flatten ( ) > > > a1 [ 0 ] = 99 > > > print ( x ) # Original array [ [ 1   2   3   4 ] [ 5   6   7   8 ] [ 9 10 11 12 ] ] > > > print ( a1 ) # New array [ 99   2   3   4   5   6   7   8   9 10 11 12 ] use ravel , changes new array affect 
 parent array . example : > > > a2 = x . ravel ( ) > > > a2 [ 0 ] = 98 > > > print ( x ) # Original array [ [ 98   2   3   4 ] [ 5   6   7   8 ] [ 9 10 11 12 ] ] > > > print ( a2 ) # New array [ 98   2   3   4   5   6   7   8   9 10 11 12 ] Read flatten ndarray.flatten ravel ravel . access docstring information # section covers help ( ) , ? , ? ? comes data science ecosystem , Python NumPy built 
 user mind . best examples built - access 
 documentation . object contains reference string , known 
 docstring . cases , docstring contains quick concise 
 summary object use . Python built - help ( ) function help access information . means nearly 
 time need information , use help ( ) quickly find 
 information need . example : > > > help ( max ) Help built - function max module builtins : max ( ... ) max(iterable , * [ , default = obj , key = func ] ) - > value max(arg1 , arg2 , * args , * [ , key = func ] ) - > value single iterable argument , return biggest item . default keyword - argument specifies object return provided iterable . arguments , return largest argument . access additional information useful , IPython uses ? character shorthand accessing documentation 
 relevant information . IPython command shell interactive computing 
 multiple languages . find information IPython . example : [ 0 ] : max ? max(iterable , * [ , default = obj , key = func ] ) - > value max(arg1 , arg2 , * args , * [ , key = func ] ) - > value single iterable argument , return biggest item . default keyword - argument specifies object return provided iterable . arguments , return largest argument . Type :       builtin_function_or_method use notation object methods objects . Let create array : > > > = np . array ( [ 1 , 2 , 3 , 4 , 5 , 6 ] ) obtain lot useful information ( details , 
 followed docstring ndarray instance ): [ 1 ] : ? Type :             ndarray String form :      [ 1 2 3 4 5 6 ] Length :           6 File :             ~/anaconda3 / lib / python3.9 / site - packages / numpy/__init__.py Docstring :        < docstring > Class docstring : ndarray(shape , dtype = float , buffer = , offset=0 , strides = , order = ) array object represents multidimensional , homogeneous array fixed - size items .   associated data - type object describes format element array ( byte - order , bytes occupies memory , integer , floating point number , , etc . ) Arrays constructed ` array ` , ` zeros ` ` ` ( refer section ) .   parameters given refer low - level method ( ` ndarray ( ... ) ` ) instantiating array . information , refer ` numpy ` module examine methods attributes array . Parameters ---------- ( _ _ new _ _ method ; Notes ) shape : tuple ints Shape created array . ... works functions objects create . 
 remember include docstring function string literal 
 ( " " " " " " ' '' ' '' documentation ) . example , create function : > > > def double ( ): ... '' ' Return * 2 '' ' ... return * 2 obtain information function : [ 2 ] : double ? Signature : double(a ) Docstring : Return * 2 File :       ~/Desktop/<ipython - input-23 - b5adf20be596 > Type :       function reach level information reading source code 
 object interested . double question mark ( ? ? ) allows 
 access source code . example : [ 3 ] : double ? ? Signature : double(a ) Source : def double(a ): '' ' Return * 2 '' ' return * 2 File :       ~/Desktop/<ipython - input-23 - b5adf20be596 > Type :       function object question compiled language Python , ? ? return information ? . find lot 
 built - objects types , example : [ 4 ] : len ? Signature : len(obj , / ) Docstring : Return number items container . Type :       builtin_function_or_method : [ 5 ] : len ? ? Signature : len(obj , / ) Docstring : Return number items container . Type :       builtin_function_or_method output compiled programming language 
 Python . Working mathematical formulas # ease implementing mathematical formulas work arrays 
 things NumPy widely scientific Python community . example , mean square error formula ( central formula 
 supervised machine learning models deal regression ): Implementing formula simple straightforward NumPy : makes work predictions labels contain 
 thousand values . need size . visualize way : example , predictions labels vectors contain values , 
 meaning n value . carry subtractions values 
 vector squared . NumPy sums values , result 
 error value prediction score quality model . save load NumPy objects # section covers np.save , np.savez , np.savetxt , np.load , np.loadtxt , point , want save arrays disk load 
 having - run code . Fortunately , ways save 
 load objects NumPy . ndarray objects saved loaded 
 disk files loadtxt savetxt functions handle normal 
 text files , load save functions handle NumPy binary files 
 .npy file extension , savez function handles NumPy files 
 .npz file extension . .npy .npz files store data , shape , dtype , information 
 required reconstruct ndarray way allows array 
 correctly retrieved , file machine different 
 architecture . want store single ndarray object , store .npy file np.save . want store ndarray object single file , 
 save .npz file np.savez . save arrays 
 single file compressed npz format savez_compressed . easy save load array np.save ( ) . sure 
 specify array want save file . example , create 
 array : > > > = np . array ( [ 1 , 2 , 3 , 4 , 5 , 6 ] ) save “ filename.npy ” : > > > np . save ( ' filename ' , ) use np.load ( ) reconstruct array . > > > b = np . load ( ' filename.npy ' ) want check array , run : > > > print ( b ) [ 1 2 3 4 5 6 ] save NumPy array plain text file like .csv .txt file 
 np.savetxt . example , create array : > > > csv_arr = np . array ( [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] ) easily save .csv file “ new_file.csv ” like : > > > np . savetxt ( ' new_file.csv ' , csv_arr ) quickly easily load saved text file loadtxt ( ) : > > > np . loadtxt ( ' new_file.csv ' ) array([1 . , 2 . , 3 . , 4 . , 5 . , 6 . , 7 . , 8 . ] ) savetxt ( ) loadtxt ( ) functions accept additional optional 
 parameters header , footer , delimiter . text files easier 
 sharing , .npy .npz files smaller faster read . need 
 sophisticated handling text file ( example , need work 
 lines contain missing values ) , want use genfromtxt function . savetxt , specify headers , footers , comments , . Learn input output routines . Importing exporting CSV # simple read CSV contains existing information . best 
 easiest way use Pandas . > > > import pandas pd > > > # columns type : > > > x = pd . read_csv ( ' music.csv ' , header = 0 ) . values > > > print ( x ) [ [ ' Billie Holiday ' ' Jazz ' 1300000 27000000 ] [ ' Jimmie Hendrix ' ' Rock ' 2700000 70000000 ] [ ' Miles Davis ' ' Jazz ' 1500000 48000000 ] [ ' SIA ' ' Pop ' 2000000 74000000 ] ] > > > # simply select columns need : > > > x = pd . read_csv ( ' music.csv ' , usecols = [ ' Artist ' , ' Plays ' ] ) . values > > > print ( x ) [ [ ' Billie Holiday ' 27000000 ] [ ' Jimmie Hendrix ' 70000000 ] [ ' Miles Davis ' 48000000 ] [ ' SIA ' 74000000 ] ] simple use Pandas order export array . new 
 NumPy , want   create Pandas dataframe values 
 array write data frame CSV file Pandas . created array “ ” > > > = np . array ( [ [ - 2.58289208 , 0.43014843 , - 1.24082018 , 1.59572603 ] , ... [ 0.99027828 , 1.17150989 , 0.94125714 , - 0.14692469 ] , ... [ 0.76989341 , 0.81299683 , - 0.95068423 , 0.11769564 ] , ... [ 0.20484034 , 0.34784527 , 1.96979195 , 0.51992837 ] ] ) create Pandas dataframe > > > df = pd . DataFrame ( ) > > > print ( df ) 0          1          2          3 0 -2.582892   0.430148 -1.240820   1.595726 1   0.990278   1.171510   0.941257 -0.146925 2   0.769893   0.812997 -0.950684   0.117696 3   0.204840   0.347845   1.969792   0.519928 easily save dataframe : > > > df . to_csv ( ' pd.csv ' ) read CSV : > > > data = pd . read_csv ( ' pd.csv ' ) save array NumPy savetxt method . > > > np . savetxt ( ' np.csv ' , , fmt = ' % .2f ' , delimiter = ' , ' , header = ' 1 ,   2 ,   3 ,   4 ' ) command line , read saved CSV time 
 command : $ cat np.csv 
 #   1 ,   2 ,   3 ,   4 
 -2.58,0.43,-1.24,1.60 
 0.99,1.17,0.94,-0.15 
 0.77,0.81,-0.95,0.12 
 0.20,0.35,1.97,0.52 open file time text editor ! interested learning Pandas , look official Pandas documentation . 
 Learn install Pandas official Pandas installation information . Plotting arrays Matplotlib # need generate plot values , simple Matplotlib . example , array like : > > > = np . array ( [ 2 , 1 , 5 , 7 , 4 , 6 , 8 , 14 , 10 , 9 , 18 , 20 , 22 ] ) Matplotlib installed , import : > > > import matplotlib.pyplot plt # Jupyter Notebook , want run following # line code display code notebook : % matplotlib inline need plot values run : > > > plt . plot ( ) # running command line , need : # > > > plt.show ( ) example , plot 1D array like : > > > x = np . linspace ( 0 , 5 , 20 ) > > > y = np . linspace ( 0 , 10 , 20 ) > > > plt . plot ( x , y , ' purple ' ) # line > > > plt . plot ( x , y , ' o ' ) # dots Matplotlib , access enormous number visualization options . > > > fig = plt . figure ( ) > > > ax = fig . add_subplot ( projection = ' 3d ' ) > > > X = np . arange ( - 5 , 5 , 0.15 ) > > > Y = np . arange ( - 5 , 5 , 0.15 ) > > > X , Y = np . meshgrid ( X , Y ) > > > R = np . sqrt ( X * * 2 + Y * * 2 ) > > > Z = np . sin ( R ) > > > ax . plot_surface ( X , Y , Z , rstride = 1 , cstride = 1 , cmap = ' viridis ' ) read Matplotlib , look official documentation . 
 directions installing Matplotlib , official installation section . Image credits : Jay Alammar https://jalammar.github.io/ previous NumPy quickstart NumPy fundamentals page import NumPy Reading example code use NumPy ? “ array ” ? Array fundamentals Array attributes create basic array Adding , removing , sorting elements know shape size array ? reshape array ? convert 1D array 2D array ( add new axis array ) Indexing slicing create array existing data Basic array operations Broadcasting useful array operations Creating matrices Generating random numbers unique items counts Transposing reshaping matrix reverse array Reshaping flattening multidimensional arrays access docstring information Working mathematical formulas save load NumPy objects Importing exporting CSV Plotting arrays Matplotlib © Copyright 2008 - 2024 , NumPy Developers . Created Sphinx 7.2.6 . Built PyData Sphinx Theme 0.16.0 .