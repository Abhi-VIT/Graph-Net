scipy data fitting – Python Data Analysis lesson early stages development ( Alpha version ) Toggle navigation Home Code Conduct Setup Episodes Working Numpy Arrays pandas data analysis scipy data fitting page ( Beta ) Extras Reference Discussion Figures Instructor Notes License Improve page previous episode Python Data Analysis lesson home scipy data fitting Overview Teaching : 20 min Exercises : 20 min Questions fit data specified function ? assess quality fit ? determine standard error fit parameters ? Objectives Use curve_fit scipy fit data specified functional form . Data fitting Python power tool fitting data functional form . longer limited simple linear polynominal functions fit spreadsheet program . calculate standard error parameter functional fit . basic steps fitting data : Import curve_fit function scipy . Create list numpy array independent variable ( x values ) . read data source , like CSV file . Create list numpy array depedent variables ( y values ) . read data source , like CSV file . Create function equation want fit . function accept inputs independent variable(s ) parameters fit . Use function curve_fit fit data . Extract fit parameters output curve_fit . Use function calculate y values fit model model fits data . Graph original data fit equation . Fitting x , y Data , import relevant python modules . import numpy np import matplotlib.pyplot plt scipy.optimize import curve_fit consider set x , y - data .   data independent variable ( x values ) dependent variable ( y values ) .   recast data numpy arrays , use numpy features evaluating data .   helpful look plot data deciding functional form fit . xdata = [ - 10.0 , - 9.0 , - 8.0 , - 7.0 , - 6.0 , - 5.0 , - 4.0 , - 3.0 , - 2.0 , - 1.0 , 0.0 , 1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0 , 10.0 ] ydata = [ 1.2 , 4.2 , 6.7 , 8.3 , 10.6 , 11.7 , 13.5 , 14.5 , 15.7 , 16.1 , 16.6 , 16.0 , 15.4 , 14.4 , 14.2 , 12.7 , 10.3 , 8.6 , 6.1 , 3.9 , 2.1 ] # Recast xdata ydata numpy arrays use handy features xdata = np . asarray ( xdata ) ydata = np . asarray ( ydata ) plt . plot ( xdata , ydata , ' o ' ) data probably fit functional forms . try different functional forms . ( Looking data knowing function fit non - trivial scope lesson . purposes lesson , simply fit data given functional forms . ) Gaussian Function : \(y = e^{-Bx^2}\ ) Cosine Function : \(D cos ( E x)\ ) Example 1 - Gaussian function , let fit data Gaussian function .   goal find values B best fit data .   , need write python function Gaussian function equation .   function accept inputs independent varible ( x - values ) parameters fit . # Define Gaussian function def Gauss ( x , , B ): y = * np . exp ( - 1 * B * x * * 2 ) return y use function curve_fit python module scipy.optimize fit data .   uses non - linear squares fit data functional form .    learn curve_fit help function Jupyter notebook scipy online documentation . curve_fit function required inputs : function want fit , x - data , y - data fitting .   outputs .   array optimal values parameters . second matrix estimated covariance parameters calculate standard error parameters . parameters , covariance = curve_fit ( Gauss , xdata , ydata ) optimized values B stored list parameters .   , extract best fit values B print . fit_A = parameters [ 0 ] fit_B = parameters [ 1 ] print ( fit_A ) print ( fit_B ) 16.934286340519687 
 0.015739600927241554 want fit equation matched data . , calculate values y , function fit values B , plot compare calculated values data . fit_y = Gauss ( xdata , fit_A , fit_B ) plt . plot ( xdata , ydata , ' o ' , label = ' data ' ) plt . plot ( xdata , fit_y , ' - ' , label = ' fit ' ) plt . legend ( ) Looks like good fit ! calculate standard error parameters covariance , square root diagonal elements matrix .   line functions numpy . SE = np . sqrt ( np . diag ( covariance ) ) SE_A = SE [ 0 ] SE_B = SE [ 1 ] print ( F ' value { fit_A : . 5 f } standard error { SE_A : . 5 f } . ' ) print ( F ' value B { fit_B : . 5 f } standard error { SE_B : . 5 f } . ' ) value 16.93429 standard error 0.35658 . 
 value B 0.01574 standard error 0.00087 . Example 2 - cosine function cosine function proves bit trickier . approach problem , graph good fit . def cos_func ( x , D , E ): y = D * np . cos ( E * x ) return y parameters , covariance = curve_fit ( cos_func , xdata , ydata ) fit_D = parameters [ 0 ] fit_E = parameters [ 1 ] fit_cosine = cos_func ( xdata , fit_D , fit_E ) plt . plot ( xdata , ydata , ' o ' , label = ' data ' ) plt . plot ( xdata , fit_cosine , ' - ' , label = ' fit ' ) fix , need guess think parameters .   Thinking form cosine function , height function controlled D parameter .   Looking graph , value D 15 17 , guess 16 .   Similarly , E parameter tells cycles occur 0 2 $ \pi$ interval .   wide graph ; clearly cycle 0 2 $ \pi$ , guess E 0.1 .   incorporate guesses code , create new array called guess .   specify guess curve_fit . guess = [ 16 , 0.1 ] parameters , covariance = curve_fit ( cos_func , xdata , ydata , p0 = guess ) fit_D = parameters [ 0 ] fit_E = parameters [ 1 ] fit_cosine = cos_func ( xdata , fit_D , fit_E ) plt . plot ( xdata , ydata , ' o ' , label = ' data ' ) plt . plot ( xdata , fit_cosine , ' - ' , label = ' fit ' ) plt . savefig ( ' 03-cosine_fit2.png ' ) looks like good fit ! Frequently , adjust guesses good fit data .   understand physical significance data equation trying fit , easier time fitting data . Exercise Calculate standard error D E parameters . Print parameter standard error . Solution SE = np . sqrt ( np . diag ( covariance ) ) SE_D = SE [ 0 ] SE_E = SE [ 1 ] print ( F ' values D { fit_D : . 5 f } standard error { SE_D : . 5 f } . ' ) print ( F ' value E { fit_E : . 5 f } standard error { SE_E : . 5 f } . ' ) values D 16.31473 standard error 0.11091 . 
 value E 0.14649 standard error 0.00090 . Exercise - Fitting Lennard - Jones potential Consider following data computed helium dimer .   interaction energy different internuclear separations given .   Fit data Lennard - Jones potential . 
 \(V = 4 \varepsilon \left ( \left ( \sigma / r \right)^{12 } - \left ( \sigma / r \right)^6 \right)\ ) # Internuclear separation angstroms distances = [ 2.875 , 3.0 , 3.125 , 3.25 , 3.375 , 3.5 , 3.75 , 4.0 , 4.5 , 5.0 , 6.0 ] # Energy Wavenumbers energies = [ 0.35334378061169025 , - 2.7260131253801405 , - 4.102738968283382 , - 4.557042640311599 , - 4.537519193684069 , - 4.296388508321034 , - 3.6304745046204117 , - 3.0205368595885536 , - 2.1929538006724814 , - 1.7245616790238782 , - 1.2500789753171557 ] Solution # Internuclear separation angstroms distances = [ 2.875 , 3.0 , 3.125 , 3.25 , 3.375 , 3.5 , 3.75 , 4.0 , 4.5 , 5.0 , 6.0 ] # Energy Wavenumbers energies = [ 0.35334378061169025 , - 2.7260131253801405 , - 4.102738968283382 , - 4.557042640311599 , - 4.537519193684069 , - 4.296388508321034 , - 3.6304745046204117 , - 3.0205368595885536 , - 2.1929538006724814 , - 1.7245616790238782 , - 1.2500789753171557 ] distances = np . asarray ( distances ) energies = np . asarray ( energies ) def LJ_func ( r , epsilon , sigma ): V = 4 * epsilon * ( ( sigma / r ) * * 12 - ( sigma / r ) * * 6 ) return V parameters , covariance = curve_fit ( LJ_func , distances , energies ) fit_epsilon = parameters [ 0 ] fit_sigma = parameters [ 1 ] print ( F ' value epsilon { fit_epsilon : . 3 f } wavenumbers . ' ) print ( F ' value sigma { fit_sigma : . 3 f } angstroms . ' ) fit_energies = LJ_func ( distances , fit_epsilon , fit_sigma ) plt . plot ( distances , energies , ' o ' , label = ' data ' ) plt . plot ( distances , fit_energies , ' - ' , label = ' LJ fit ' ) value epsilon 4.857 wavenumbers . 
 value sigma 2.893 angstroms . Key Points Recasting data numpy arrays lets utilize features like broadcasting , helpful evaluating functions . initial fit model match data , use bounds argument fit_curve guess range values fit parameters . previous episode lesson home Copyright © 2018–2022 Molecular Sciences Software Institute Edit GitHub / Contributing / Source / Cite / Contact Carpentries style version 9.5.0 .