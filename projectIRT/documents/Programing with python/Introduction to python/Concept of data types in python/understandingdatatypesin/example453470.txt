Understanding Data Types Python | Python Data Science Handbook Python Data Science Handbook Archive excerpt Python Data Science Handbook Jake VanderPlas ; Jupyter notebooks available GitHub . text released CC - - NC - ND license , code released MIT license . find content useful , consider supporting work buying book ! Understanding Data Types Python < Introduction NumPy | Contents | Basics NumPy Arrays > Effective data - driven science computation requires understanding data stored manipulated . 
 section outlines contrasts arrays data handled Python language , NumPy improves . 
 Understanding difference fundamental understanding material rest book . Users Python drawn - ease use , piece dynamic typing . 
 statically - typed language like C Java requires variable explicitly declared , dynamically - typed language like Python skips specification . example , C specify particular operation follows : / * C code * / int result = 0 ; ( int = 0 ; < 100 ; + + ) { result + = ; } Python equivalent operation written way : # Python code result = 0 range ( 100 ): result + = Notice main difference : C , data types variable explicitly declared , Python types dynamically inferred . means , example , assign kind data variable : # Python code x = 4 x = " " switched contents x integer string . thing C lead ( depending compiler settings ) compilation error unintented consequences : / * C code * / int x = 4 ; x = " " ; // FAILS sort flexibility piece makes Python dynamically - typed languages convenient easy use . 
 Understanding works important piece learning analyze data efficiently effectively Python . 
 type - flexibility points fact Python variables value ; contain extra information type value . explore sections follow . Python Integer Integer ¶ standard Python implementation written C. 
 means Python object simply cleverly - disguised C structure , contains value , information . example , define integer Python , x = 10000 , x " raw " integer . actually pointer compound C structure , contains values . 
 Looking Python 3.4 source code , find integer ( long ) type definition effectively looks like ( C macros expanded ): struct _ longobject { long ob_refcnt ; PyTypeObject * ob_type ; size_t ob_size ; long ob_digit [ 1 ] ; } ; single integer Python 3.4 actually contains pieces : ob_refcnt , reference count helps Python silently handle memory allocation deallocation ob_type , encodes type variable ob_size , specifies size following data members ob_digit , contains actual integer value expect Python variable represent . means overhead storing integer Python compared integer compiled language like C , illustrated following figure : PyObject_HEAD structure containing reference count , type code , pieces mentioned . Notice difference : C integer essentially label position memory bytes encode integer value . 
 Python integer pointer position memory containing Python object information , including bytes contain integer value . 
 extra information Python integer structure allows Python coded freely dynamically . 
 additional information Python types comes cost , , especially apparent structures combine objects . Python List List ¶ Let consider happens use Python data structure holds Python objects . 
 standard mutable multi - element container Python list . 
 create list integers follows :   [ 1 ] : L = list ( range ( 10 ) ) L Out[1 ] : [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ]   [ 2 ] : type ( L [ 0 ] ) Out[2 ] : int , similarly , list strings :   [ 3 ] : L2 = [ str ( c ) c L ] L2 Out[3 ] : [ ' 0 ' , ' 1 ' , ' 2 ' , ' 3 ' , ' 4 ' , ' 5 ' , ' 6 ' , ' 7 ' , ' 8 ' , ' 9 ' ]   [ 4 ] : type ( L2 [ 0 ] ) Out[4 ] : str Python dynamic typing , create heterogeneous lists :   [ 5 ] : L3 = [ True , " 2 " , 3.0 , 4 ] [ type ( item ) item L3 ] Out[5 ] : [ bool , str , float , int ] flexibility comes cost : allow flexible types , item list contain type info , reference count , information – , item complete Python object . 
 special case variables type , information redundant : efficient store data fixed - type array . 
 difference dynamic - type list fixed - type ( NumPy - style ) array illustrated following figure : implementation level , array essentially contains single pointer contiguous block data . 
 Python list , hand , contains pointer block pointers , turn points Python object like Python integer saw earlier . 
 , advantage list flexibility : list element structure containing data type information , list filled data desired type . 
 Fixed - type NumPy - style arrays lack flexibility , efficient storing manipulating data . Fixed - Type Arrays Python ¶ Python offers different options storing data efficient , fixed - type data buffers . 
 built - array module ( available Python 3.3 ) create dense arrays uniform type :   [ 6 ] : import array L = list ( range ( 10 ) ) = array . array ( ' ' , L ) Out[6 ] : array('i ' , [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] ) ' ' type code indicating contents integers . useful , , ndarray object NumPy package . 
 Python array object provides efficient storage array - based data , NumPy adds efficient operations data . 
 explore operations later sections ; demonstrate ways creating NumPy array . start standard NumPy import , alias np :   [ 7 ] : import numpy np Creating Arrays Python Lists ¶ , use np.array create arrays Python lists :   [ 8 ] : # integer array : np . array ( [ 1 , 4 , 2 , 5 , 3 ] ) Out[8 ] : array([1 , 4 , 2 , 5 , 3 ] ) Remember unlike Python lists , NumPy constrained arrays contain type . 
 types match , NumPy upcast possible ( , integers - cast floating point ):   [ 9 ] : np . array ( [ 3.14 , 4 , 2 , 3 ] ) Out[9 ] : array ( [ 3.14 ,   4 .   ,   2 .   ,   3 .   ] ) want explicitly set data type resulting array , use dtype keyword :   [ 10 ] : np . array ( [ 1 , 2 , 3 , 4 ] , dtype = ' float32 ' ) Out[10 ] : array ( [ 1 . ,   2 . ,   3 . ,   4 . ] , dtype = float32 ) Finally , unlike Python lists , NumPy arrays explicitly multi - dimensional ; way initializing multidimensional array list lists :   [ 11 ] : # nested lists result multi - dimensional arrays np . array ( [ range ( , + 3 ) [ 2 , 4 , 6 ] ] ) Out[11 ] : array([[2 , 3 , 4 ] , 
        [ 4 , 5 , 6 ] , 
        [ 6 , 7 , 8 ] ] ) inner lists treated rows resulting - dimensional array . Creating Arrays Scratch ¶ Especially larger arrays , efficient create arrays scratch routines built NumPy . 
 examples :   [ 12 ] : # Create length-10 integer array filled zeros np . zeros ( 10 , dtype = int ) Out[12 ] : array([0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] )   [ 13 ] : # Create 3x5 floating - point array filled ones np . ones ( ( 3 , 5 ) , dtype = float ) Out[13 ] : array ( [ [ 1 . ,   1 . ,   1 . ,   1 . ,   1 . ] , 
        [ 1 . ,   1 . ,   1 . ,   1 . ,   1 . ] , 
        [ 1 . ,   1 . ,   1 . ,   1 . ,   1 . ] ] )   [ 14 ] : # Create 3x5 array filled 3.14 np . ( ( 3 , 5 ) , 3.14 ) Out[14 ] : array ( [ [ 3.14 ,   3.14 ,   3.14 ,   3.14 ,   3.14 ] , 
        [ 3.14 ,   3.14 ,   3.14 ,   3.14 ,   3.14 ] , 
        [ 3.14 ,   3.14 ,   3.14 ,   3.14 ,   3.14 ] ] )   [ 15 ] : # Create array filled linear sequence # Starting 0 , ending 20 , stepping 2 # ( similar built - range ( ) function ) np . arange ( 0 , 20 , 2 ) Out[15 ] : array ( [ 0 ,   2 ,   4 ,   6 ,   8 , 10 , 12 , 14 , 16 , 18 ] )   [ 16 ] : # Create array values evenly spaced 0 1 np . linspace ( 0 , 1 , 5 ) Out[16 ] : array ( [ 0 .   ,   0.25 ,   0.5 ,   0.75 ,   1 .   ] )   [ 17 ] : # Create 3x3 array uniformly distributed # random values 0 1 np . random . random ( ( 3 , 3 ) ) Out[17 ] : array ( [ [ 0.99844933 ,   0.52183819 ,   0.22421193 ] , 
        [ 0.08007488 ,   0.45429293 ,   0.20941444 ] , 
        [ 0.14360941 ,   0.96910973 ,   0.946117   ] ] )   [ 18 ] : # Create 3x3 array normally distributed random values # mean 0 standard deviation 1 np . random . normal ( 0 , 1 , ( 3 , 3 ) ) Out[18 ] : array ( [ [ 1.51772646 ,   0.39614948 , -0.10634696 ] , 
        [ 0.25671348 ,   0.00732722 ,   0.37783601 ] , 
        [ 0.68446945 ,   0.15926039 , -0.70744073 ] ] )   [ 19 ] : # Create 3x3 array random integers interval [ 0 , 10 ) np . random . randint ( 0 , 10 , ( 3 , 3 ) ) Out[19 ] : array([[2 , 3 , 4 ] , 
        [ 5 , 7 , 8 ] , 
        [ 0 , 5 , 0 ] ] )   [ 20 ] : # Create 3x3 identity matrix np . eye ( 3 ) Out[20 ] : array ( [ [ 1 . ,   0 . ,   0 . ] , 
        [ 0 . ,   1 . ,   0 . ] , 
        [ 0 . ,   0 . ,   1 . ] ] )   [ 21 ] : # Create uninitialized array integers # values happens exist memory location np . ( 3 ) Out[21 ] : array ( [ 1 . ,   1 . ,   1 . ] ) NumPy Standard Data Types ¶ NumPy arrays contain values single type , important detailed knowledge types limitations . 
 NumPy built C , types familiar users C , Fortran , related languages . standard NumPy data types listed following table . 
 Note constructing array , specified string : np . zeros ( 10 , dtype = ' int16 ' ) associated NumPy object : np . zeros ( 10 , dtype = np . int16 ) Data type Description bool _ Boolean ( True False ) stored byte int _ Default integer type ( C long ; normally int64 int32 ) intc Identical C int ( normally int32 int64 ) intp Integer indexing ( C ssize_t ; normally int32 int64 ) int8 Byte ( -128 127 ) int16 Integer ( -32768 32767 ) int32 Integer ( -2147483648 2147483647 ) int64 Integer ( -9223372036854775808 9223372036854775807 ) uint8 Unsigned integer ( 0 255 ) uint16 Unsigned integer ( 0 65535 ) uint32 Unsigned integer ( 0 4294967295 ) uint64 Unsigned integer ( 0 18446744073709551615 ) float _ Shorthand float64 . float16 Half precision float : sign bit , 5 bits exponent , 10 bits mantissa float32 Single precision float : sign bit , 8 bits exponent , 23 bits mantissa float64 Double precision float : sign bit , 11 bits exponent , 52 bits mantissa complex _ Shorthand complex128 . complex64 Complex number , represented 32 - bit floats complex128 Complex number , represented 64 - bit floats advanced type specification possible , specifying big little endian numbers ; information , refer NumPy documentation . 
 NumPy supports compound data types , covered Structured Data : NumPy Structured Arrays . < Introduction NumPy | Contents | Basics NumPy Arrays >